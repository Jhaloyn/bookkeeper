<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>GenericData.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Test-coverage</a> &gt; <a href="../index.html" class="el_bundle">avro</a> &gt; <a href="index.source.html" class="el_package">org.apache.avro.generic</a> &gt; <span class="el_source">GenericData.java</span></div><h1>GenericData.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.avro.generic;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import org.apache.avro.AvroMissingFieldException;
import org.apache.avro.AvroRuntimeException;
import org.apache.avro.AvroTypeException;
import org.apache.avro.Conversion;
import org.apache.avro.Conversions;
import org.apache.avro.JsonProperties;
import org.apache.avro.LogicalType;
import org.apache.avro.Schema;
import org.apache.avro.Schema.Field;
import org.apache.avro.Schema.Type;
import org.apache.avro.UnresolvedUnionException;
import org.apache.avro.io.BinaryData;
import org.apache.avro.io.BinaryDecoder;
import org.apache.avro.io.BinaryEncoder;
import org.apache.avro.io.DatumReader;
import org.apache.avro.io.DatumWriter;
import org.apache.avro.io.DecoderFactory;
import org.apache.avro.io.EncoderFactory;
import org.apache.avro.io.FastReaderBuilder;
import org.apache.avro.util.Utf8;
import org.apache.avro.util.internal.Accessor;

import com.fasterxml.jackson.databind.JsonNode;

/**
 * Utilities for generic Java data. See {@link GenericRecordBuilder} for a
 * convenient way to build {@link GenericRecord} instances.
 *
 * @see GenericRecordBuilder
 */
public class GenericData {

<span class="fc" id="L68">  private static final GenericData INSTANCE = new GenericData();</span>

  /** Used to specify the Java type for a string schema. */
<span class="nc" id="L71">  public enum StringType {</span>
<span class="nc" id="L72">    CharSequence, String, Utf8</span>
  };

  public static final String STRING_PROP = &quot;avro.java.string&quot;;
  protected static final String STRING_TYPE_STRING = &quot;String&quot;;

  private final ClassLoader classLoader;

  /**
   * Set the Java type to be used when reading this schema. Meaningful only only
   * string schemas and map schemas (for the keys).
   */
  public static void setStringType(Schema s, StringType stringType) {
    // Utf8 is the default and implements CharSequence, so we only need to add
    // a property when the type is String
<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (stringType == StringType.String)</span>
<span class="nc" id="L88">      s.addProp(GenericData.STRING_PROP, GenericData.STRING_TYPE_STRING);</span>
<span class="nc" id="L89">  }</span>

  /** Return the singleton instance. */
  public static GenericData get() {
<span class="nc" id="L93">    return INSTANCE;</span>
  }

  /** For subclasses. Applications normally use {@link GenericData#get()}. */
  public GenericData() {
<span class="fc" id="L98">    this(null);</span>
<span class="fc" id="L99">  }</span>

  /** For subclasses. GenericData does not use a ClassLoader. */
<span class="fc" id="L102">  public GenericData(ClassLoader classLoader) {</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">    this.classLoader = (classLoader != null) ? classLoader : getClass().getClassLoader();</span>
<span class="fc" id="L104">  }</span>

  /** Return the class loader that's used (by subclasses). */
  public ClassLoader getClassLoader() {
<span class="nc" id="L108">    return classLoader;</span>
  }

<span class="fc" id="L111">  private Map&lt;String, Conversion&lt;?&gt;&gt; conversions = new HashMap&lt;&gt;();</span>

<span class="fc" id="L113">  private Map&lt;Class&lt;?&gt;, Map&lt;String, Conversion&lt;?&gt;&gt;&gt; conversionsByClass = new IdentityHashMap&lt;&gt;();</span>

  public Collection&lt;Conversion&lt;?&gt;&gt; getConversions() {
<span class="nc" id="L116">    return conversions.values();</span>
  }

  /**
   * Registers the given conversion to be used when reading and writing with this
   * data model.
   *
   * @param conversion a logical type Conversion.
   */
  public void addLogicalTypeConversion(Conversion&lt;?&gt; conversion) {
<span class="nc" id="L126">    conversions.put(conversion.getLogicalTypeName(), conversion);</span>
<span class="nc" id="L127">    Class&lt;?&gt; type = conversion.getConvertedType();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (conversionsByClass.containsKey(type)) {</span>
<span class="nc" id="L129">      conversionsByClass.get(type).put(conversion.getLogicalTypeName(), conversion);</span>
    } else {
<span class="nc" id="L131">      Map&lt;String, Conversion&lt;?&gt;&gt; conversions = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L132">      conversions.put(conversion.getLogicalTypeName(), conversion);</span>
<span class="nc" id="L133">      conversionsByClass.put(type, conversions);</span>
    }
<span class="nc" id="L135">  }</span>

  /**
   * Returns the first conversion found for the given class.
   *
   * @param datumClass a Class
   * @return the first registered conversion for the class, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; Conversion&lt;T&gt; getConversionByClass(Class&lt;T&gt; datumClass) {
<span class="nc" id="L145">    Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datumClass);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (conversions != null) {</span>
<span class="nc" id="L147">      return (Conversion&lt;T&gt;) conversions.values().iterator().next();</span>
    }
<span class="nc" id="L149">    return null;</span>
  }

  /**
   * Returns the conversion for the given class and logical type.
   *
   * @param datumClass  a Class
   * @param logicalType a LogicalType
   * @return the conversion for the class and logical type, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; Conversion&lt;T&gt; getConversionByClass(Class&lt;T&gt; datumClass, LogicalType logicalType) {
<span class="nc" id="L161">    Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datumClass);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (conversions != null) {</span>
<span class="nc" id="L163">      return (Conversion&lt;T&gt;) conversions.get(logicalType.getName());</span>
    }
<span class="nc" id="L165">    return null;</span>
  }

  /**
   * Returns the Conversion for the given logical type.
   *
   * @param logicalType a logical type
   * @return the conversion for the logical type, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Conversion&lt;Object&gt; getConversionFor(LogicalType logicalType) {
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if (logicalType == null) {</span>
<span class="nc" id="L177">      return null;</span>
    }
<span class="nc" id="L179">    return (Conversion&lt;Object&gt;) conversions.get(logicalType.getName());</span>
  }

  public static final String FAST_READER_PROP = &quot;org.apache.avro.fastread&quot;;
<span class="fc" id="L183">  private boolean fastReaderEnabled = &quot;true&quot;.equalsIgnoreCase(System.getProperty(FAST_READER_PROP));</span>
<span class="fc" id="L184">  private FastReaderBuilder fastReaderBuilder = null;</span>

  public GenericData setFastReaderEnabled(boolean flag) {
<span class="nc" id="L187">    this.fastReaderEnabled = flag;</span>
<span class="nc" id="L188">    return this;</span>
  }

  public boolean isFastReaderEnabled() {
<span class="nc bnc" id="L192" title="All 4 branches missed.">    return fastReaderEnabled &amp;&amp; FastReaderBuilder.isSupportedData(this);</span>
  }

  public FastReaderBuilder getFastReaderBuilder() {
<span class="nc bnc" id="L196" title="All 2 branches missed.">    if (fastReaderBuilder == null) {</span>
<span class="nc" id="L197">      fastReaderBuilder = new FastReaderBuilder(this);</span>
    }
<span class="nc" id="L199">    return this.fastReaderBuilder;</span>
  }

  /**
   * Default implementation of {@link GenericRecord}. Note that this
   * implementation does not fill in default values for fields if they are not
   * specified; use {@link GenericRecordBuilder} in that case.
   *
   * @see GenericRecordBuilder
   */
  public static class Record implements GenericRecord, Comparable&lt;Record&gt; {
    private final Schema schema;
    private final Object[] values;

<span class="fc" id="L213">    public Record(Schema schema) {</span>
<span class="pc bpc" id="L214" title="2 of 4 branches missed.">      if (schema == null || !Type.RECORD.equals(schema.getType()))</span>
<span class="nc" id="L215">        throw new AvroRuntimeException(&quot;Not a record schema: &quot; + schema);</span>
<span class="fc" id="L216">      this.schema = schema;</span>
<span class="fc" id="L217">      this.values = new Object[schema.getFields().size()];</span>
<span class="fc" id="L218">    }</span>

<span class="nc" id="L220">    public Record(Record other, boolean deepCopy) {</span>
<span class="nc" id="L221">      schema = other.schema;</span>
<span class="nc" id="L222">      values = new Object[schema.getFields().size()];</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">      if (deepCopy) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (int ii = 0; ii &lt; values.length; ii++) {</span>
<span class="nc" id="L225">          values[ii] = INSTANCE.deepCopy(schema.getFields().get(ii).schema(), other.values[ii]);</span>
        }
      } else {
<span class="nc" id="L228">        System.arraycopy(other.values, 0, values, 0, other.values.length);</span>
      }
<span class="nc" id="L230">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L234">      return schema;</span>
    }

    @Override
    public void put(String key, Object value) {
<span class="fc" id="L239">      Schema.Field field = schema.getField(key);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      if (field == null)</span>
<span class="nc" id="L241">        throw new AvroRuntimeException(&quot;Not a valid schema field: &quot; + key);</span>

<span class="fc" id="L243">      values[field.pos()] = value;</span>
<span class="fc" id="L244">    }</span>

    @Override
    public void put(int i, Object v) {
<span class="nc" id="L248">      values[i] = v;</span>
<span class="nc" id="L249">    }</span>

    @Override
    public Object get(String key) {
<span class="nc" id="L253">      Field field = schema.getField(key);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (field == null)</span>
<span class="nc" id="L255">        return null;</span>
<span class="nc" id="L256">      return values[field.pos()];</span>
    }

    @Override
    public Object get(int i) {
<span class="fc" id="L261">      return values[i];</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L267">        return true; // identical object</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (!(o instanceof Record))</span>
<span class="nc" id="L269">        return false; // not a record</span>
<span class="nc" id="L270">      Record that = (Record) o;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (!this.schema.equals(that.schema))</span>
<span class="nc" id="L272">        return false; // not the same schema</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      return GenericData.get().compare(this, that, schema, true) == 0;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L278">      return GenericData.get().hashCode(this, schema);</span>
    }

    @Override
    public int compareTo(Record that) {
<span class="nc" id="L283">      return GenericData.get().compare(this, that, schema);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L288">      return GenericData.get().toString(this);</span>
    }
  }

  /** Default implementation of an array. */
  @SuppressWarnings(value = &quot;unchecked&quot;)
  public static class Array&lt;T&gt; extends AbstractList&lt;T&gt; implements GenericArray&lt;T&gt;, Comparable&lt;GenericArray&lt;T&gt;&gt; {
<span class="nc" id="L295">    private static final Object[] EMPTY = new Object[0];</span>
    private final Schema schema;
    private int size;
<span class="nc" id="L298">    private Object[] elements = EMPTY;</span>

<span class="nc" id="L300">    public Array(int capacity, Schema schema) {</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">      if (schema == null || !Type.ARRAY.equals(schema.getType()))</span>
<span class="nc" id="L302">        throw new AvroRuntimeException(&quot;Not an array schema: &quot; + schema);</span>
<span class="nc" id="L303">      this.schema = schema;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (capacity != 0)</span>
<span class="nc" id="L305">        elements = new Object[capacity];</span>
<span class="nc" id="L306">    }</span>

<span class="nc" id="L308">    public Array(Schema schema, Collection&lt;T&gt; c) {</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">      if (schema == null || !Type.ARRAY.equals(schema.getType()))</span>
<span class="nc" id="L310">        throw new AvroRuntimeException(&quot;Not an array schema: &quot; + schema);</span>
<span class="nc" id="L311">      this.schema = schema;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">      if (c != null) {</span>
<span class="nc" id="L313">        elements = new Object[c.size()];</span>
<span class="nc" id="L314">        addAll(c);</span>
      }
<span class="nc" id="L316">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L320">      return schema;</span>
    }

    @Override
    public int size() {
<span class="nc" id="L325">      return size;</span>
    }

    @Override
    public void clear() {
      // Let GC do its work
<span class="nc" id="L331">      Arrays.fill(elements, 0, size, null);</span>
<span class="nc" id="L332">      size = 0;</span>
<span class="nc" id="L333">    }</span>

    @Override
    public void reset() {
<span class="nc" id="L337">      size = 0;</span>
<span class="nc" id="L338">    }</span>

    @Override
    public void prune() {
<span class="nc bnc" id="L342" title="All 2 branches missed.">      if (size &lt; elements.length) {</span>
<span class="nc" id="L343">        Arrays.fill(elements, size, elements.length, null);</span>
      }
<span class="nc" id="L345">    }</span>

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="nc" id="L349">      return new Iterator&lt;T&gt;() {</span>
<span class="nc" id="L350">        private int position = 0;</span>

        @Override
        public boolean hasNext() {
<span class="nc bnc" id="L354" title="All 2 branches missed.">          return position &lt; size;</span>
        }

        @Override
        public T next() {
<span class="nc" id="L359">          return (T) elements[position++];</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L364">          throw new UnsupportedOperationException();</span>
        }
      };
    }

    @Override
    public T get(int i) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L372">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L373">      return (T) elements[i];</span>
    }

    @Override
    public void add(int location, T o) {
<span class="nc bnc" id="L378" title="All 4 branches missed.">      if (location &gt; size || location &lt; 0) {</span>
<span class="nc" id="L379">        throw new IndexOutOfBoundsException(&quot;Index &quot; + location + &quot; out of bounds.&quot;);</span>
      }
<span class="nc bnc" id="L381" title="All 2 branches missed.">      if (size == elements.length) {</span>
        // Increase size by 1.5x + 1
<span class="nc" id="L383">        final int newSize = size + (size &gt;&gt; 1) + 1;</span>
<span class="nc" id="L384">        elements = Arrays.copyOf(elements, newSize);</span>
      }
<span class="nc" id="L386">      System.arraycopy(elements, location, elements, location + 1, size - location);</span>
<span class="nc" id="L387">      elements[location] = o;</span>
<span class="nc" id="L388">      size++;</span>
<span class="nc" id="L389">    }</span>

    @Override
    public T set(int i, T o) {
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L394">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L395">      T response = (T) elements[i];</span>
<span class="nc" id="L396">      elements[i] = o;</span>
<span class="nc" id="L397">      return response;</span>
    }

    @Override
    public T remove(int i) {
<span class="nc bnc" id="L402" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L403">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L404">      T result = (T) elements[i];</span>
<span class="nc" id="L405">      --size;</span>
<span class="nc" id="L406">      System.arraycopy(elements, i + 1, elements, i, (size - i));</span>
<span class="nc" id="L407">      elements[size] = null;</span>
<span class="nc" id="L408">      return result;</span>
    }

    @Override
    public T peek() {
<span class="nc bnc" id="L413" title="All 2 branches missed.">      return (size &lt; elements.length) ? (T) elements[size] : null;</span>
    }

    @Override
    public int compareTo(GenericArray&lt;T&gt; that) {
<span class="nc" id="L418">      return GenericData.get().compare(this, that, this.getSchema());</span>
    }

    @Override
    public void reverse() {
<span class="nc" id="L423">      int left = 0;</span>
<span class="nc" id="L424">      int right = elements.length - 1;</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">      while (left &lt; right) {</span>
<span class="nc" id="L427">        Object tmp = elements[left];</span>
<span class="nc" id="L428">        elements[left] = elements[right];</span>
<span class="nc" id="L429">        elements[right] = tmp;</span>

<span class="nc" id="L431">        left++;</span>
<span class="nc" id="L432">        right--;</span>
<span class="nc" id="L433">      }</span>
<span class="nc" id="L434">    }</span>
  }

  /** Default implementation of {@link GenericFixed}. */
  public static class Fixed implements GenericFixed, Comparable&lt;Fixed&gt; {
    private Schema schema;
    private byte[] bytes;

<span class="nc" id="L442">    public Fixed(Schema schema) {</span>
<span class="nc" id="L443">      setSchema(schema);</span>
<span class="nc" id="L444">    }</span>

<span class="fc" id="L446">    public Fixed(Schema schema, byte[] bytes) {</span>
<span class="fc" id="L447">      this.schema = schema;</span>
<span class="fc" id="L448">      this.bytes = bytes;</span>
<span class="fc" id="L449">    }</span>

<span class="nc" id="L451">    protected Fixed() {</span>
<span class="nc" id="L452">    }</span>

    protected void setSchema(Schema schema) {
<span class="nc" id="L455">      this.schema = schema;</span>
<span class="nc" id="L456">      this.bytes = new byte[schema.getFixedSize()];</span>
<span class="nc" id="L457">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L461">      return schema;</span>
    }

    public void bytes(byte[] bytes) {
<span class="nc" id="L465">      this.bytes = bytes;</span>
<span class="nc" id="L466">    }</span>

    @Override
    public byte[] bytes() {
<span class="fc" id="L470">      return bytes;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L476">        return true;</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">      return o instanceof GenericFixed &amp;&amp; Arrays.equals(bytes, ((GenericFixed) o).bytes());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L482">      return Arrays.hashCode(bytes);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L487">      return Arrays.toString(bytes);</span>
    }

    @Override
    public int compareTo(Fixed that) {
<span class="fc" id="L492">      return BinaryData.compareBytes(this.bytes, 0, this.bytes.length, that.bytes, 0, that.bytes.length);</span>
    }
  }

  /** Default implementation of {@link GenericEnumSymbol}. */
  public static class EnumSymbol implements GenericEnumSymbol&lt;EnumSymbol&gt; {
    private Schema schema;
    private String symbol;

<span class="fc" id="L501">    public EnumSymbol(Schema schema, String symbol) {</span>
<span class="fc" id="L502">      this.schema = schema;</span>
<span class="fc" id="L503">      this.symbol = symbol;</span>
<span class="fc" id="L504">    }</span>

    /**
     * Maps existing Objects into an Avro enum by calling toString(), eg for Java
     * Enums
     */
    public EnumSymbol(Schema schema, Object symbol) {
<span class="nc" id="L511">      this(schema, symbol.toString());</span>
<span class="nc" id="L512">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L516">      return schema;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L521" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L522">        return true;</span>
<span class="nc bnc" id="L523" title="All 4 branches missed.">      return o instanceof GenericEnumSymbol &amp;&amp; symbol.equals(o.toString());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L528">      return symbol.hashCode();</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L533">      return symbol;</span>
    }

    @Override
    public int compareTo(EnumSymbol that) {
<span class="nc" id="L538">      return GenericData.get().compare(this, that, schema);</span>
    }
  }

  /** Returns a {@link DatumReader} for this kind of data. */
  public DatumReader createDatumReader(Schema schema) {
<span class="nc" id="L544">    return createDatumReader(schema, schema);</span>
  }

  /** Returns a {@link DatumReader} for this kind of data. */
  public DatumReader createDatumReader(Schema writer, Schema reader) {
<span class="nc" id="L549">    return new GenericDatumReader(writer, reader, this);</span>
  }

  /** Returns a {@link DatumWriter} for this kind of data. */
  public DatumWriter createDatumWriter(Schema schema) {
<span class="nc" id="L554">    return new GenericDatumWriter(schema, this);</span>
  }

  /** Returns true if a Java datum matches a schema. */
  public boolean validate(Schema schema, Object datum) {
<span class="pc bpc" id="L559" title="1 of 15 branches missed.">    switch (schema.getType()) {</span>
    case RECORD:
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">      if (!isRecord(datum))</span>
<span class="nc" id="L562">        return false;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">      for (Field f : schema.getFields()) {</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        if (!validate(f.schema(), getField(datum, f.name(), f.pos())))</span>
<span class="nc" id="L565">          return false;</span>
<span class="fc" id="L566">      }</span>
<span class="fc" id="L567">      return true;</span>
    case ENUM:
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">      if (!isEnum(datum))</span>
<span class="nc" id="L570">        return false;</span>
<span class="fc" id="L571">      return schema.getEnumSymbols().contains(datum.toString());</span>
    case ARRAY:
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">      if (!(isArray(datum)))</span>
<span class="nc" id="L574">        return false;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">      for (Object element : getArrayAsCollection(datum))</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (!validate(schema.getElementType(), element))</span>
<span class="nc" id="L577">          return false;</span>
<span class="fc" id="L578">      return true;</span>
    case MAP:
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">      if (!(isMap(datum)))</span>
<span class="fc" id="L581">        return false;</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L583">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet())</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (!validate(schema.getValueType(), entry.getValue()))</span>
<span class="nc" id="L586">          return false;</span>
<span class="nc" id="L587">      return true;</span>
    case UNION:
      try {
<span class="fc" id="L590">        int i = resolveUnion(schema, datum);</span>
<span class="fc" id="L591">        return validate(schema.getTypes().get(i), datum);</span>
<span class="nc" id="L592">      } catch (UnresolvedUnionException e) {</span>
<span class="nc" id="L593">        return false;</span>
      }
    case FIXED:
<span class="pc bpc" id="L596" title="2 of 4 branches missed.">      return datum instanceof GenericFixed &amp;&amp; ((GenericFixed) datum).bytes().length == schema.getFixedSize();</span>
    case STRING:
<span class="fc" id="L598">      return isString(datum);</span>
    case BYTES:
<span class="fc" id="L600">      return isBytes(datum);</span>
    case INT:
<span class="fc" id="L602">      return isInteger(datum);</span>
    case LONG:
<span class="fc" id="L604">      return isLong(datum);</span>
    case FLOAT:
<span class="fc" id="L606">      return isFloat(datum);</span>
    case DOUBLE:
<span class="fc" id="L608">      return isDouble(datum);</span>
    case BOOLEAN:
<span class="fc" id="L610">      return isBoolean(datum);</span>
    case NULL:
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">      return datum == null;</span>
    default:
<span class="nc" id="L614">      return false;</span>
    }
  }

  /** Renders a Java datum as &lt;a href=&quot;https://www.json.org/&quot;&gt;JSON&lt;/a&gt;. */
  public String toString(Object datum) {
<span class="nc" id="L620">    StringBuilder buffer = new StringBuilder();</span>
<span class="nc" id="L621">    toString(datum, buffer, new IdentityHashMap&lt;&gt;(128));</span>
<span class="nc" id="L622">    return buffer.toString();</span>
  }

  private static final String TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT = &quot; \&quot;&gt;&gt;&gt; CIRCULAR REFERENCE CANNOT BE PUT IN JSON STRING, ABORTING RECURSION &lt;&lt;&lt;\&quot; &quot;;

  /** Renders a Java datum as &lt;a href=&quot;https://www.json.org/&quot;&gt;JSON&lt;/a&gt;. */
  protected void toString(Object datum, StringBuilder buffer, IdentityHashMap&lt;Object, Object&gt; seenObjects) {
<span class="nc bnc" id="L629" title="All 2 branches missed.">    if (isRecord(datum)) {</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L631">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L632">        return;</span>
      }
<span class="nc" id="L634">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L635">      buffer.append(&quot;{&quot;);</span>
<span class="nc" id="L636">      int count = 0;</span>
<span class="nc" id="L637">      Schema schema = getRecordSchema(datum);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">      for (Field f : schema.getFields()) {</span>
<span class="nc" id="L639">        toString(f.name(), buffer, seenObjects);</span>
<span class="nc" id="L640">        buffer.append(&quot;: &quot;);</span>
<span class="nc" id="L641">        toString(getField(datum, f.name(), f.pos()), buffer, seenObjects);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (++count &lt; schema.getFields().size())</span>
<span class="nc" id="L643">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L644">      }</span>
<span class="nc" id="L645">      buffer.append(&quot;}&quot;);</span>
<span class="nc" id="L646">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">    } else if (isArray(datum)) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L649">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L650">        return;</span>
      }
<span class="nc" id="L652">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L653">      Collection&lt;?&gt; array = getArrayAsCollection(datum);</span>
<span class="nc" id="L654">      buffer.append(&quot;[&quot;);</span>
<span class="nc" id="L655">      long last = array.size() - 1;</span>
<span class="nc" id="L656">      int i = 0;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">      for (Object element : array) {</span>
<span class="nc" id="L658">        toString(element, buffer, seenObjects);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (i++ &lt; last)</span>
<span class="nc" id="L660">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L661">      }</span>
<span class="nc" id="L662">      buffer.append(&quot;]&quot;);</span>
<span class="nc" id="L663">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">    } else if (isMap(datum)) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L666">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L667">        return;</span>
      }
<span class="nc" id="L669">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L670">      buffer.append(&quot;{&quot;);</span>
<span class="nc" id="L671">      int count = 0;</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L673">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L675">        buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L676">        writeEscapedString(String.valueOf(entry.getKey()), buffer);</span>
<span class="nc" id="L677">        buffer.append(&quot;\&quot;: &quot;);</span>
<span class="nc" id="L678">        toString(entry.getValue(), buffer, seenObjects);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (++count &lt; map.size())</span>
<span class="nc" id="L680">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L681">      }</span>
<span class="nc" id="L682">      buffer.append(&quot;}&quot;);</span>
<span class="nc" id="L683">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L684" title="All 4 branches missed.">    } else if (isString(datum) || isEnum(datum)) {</span>
<span class="nc" id="L685">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L686">      writeEscapedString(datum.toString(), buffer);</span>
<span class="nc" id="L687">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">    } else if (isBytes(datum)) {</span>
<span class="nc" id="L689">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L690">      ByteBuffer bytes = ((ByteBuffer) datum).duplicate();</span>
<span class="nc" id="L691">      writeEscapedString(StandardCharsets.ISO_8859_1.decode(bytes), buffer);</span>
<span class="nc" id="L692">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">    } else if (((datum instanceof Float) &amp;&amp; // quote Nan &amp; Infinity</span>
<span class="nc bnc" id="L694" title="All 6 branches missed.">        (((Float) datum).isInfinite() || ((Float) datum).isNaN()))</span>
<span class="nc bnc" id="L695" title="All 4 branches missed.">        || ((datum instanceof Double) &amp;&amp; (((Double) datum).isInfinite() || ((Double) datum).isNaN()))) {</span>
<span class="nc" id="L696">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L697">      buffer.append(datum);</span>
<span class="nc" id="L698">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">    } else if (datum instanceof GenericData) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L701">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L702">        return;</span>
      }
<span class="nc" id="L704">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L705">      toString(datum, buffer, seenObjects);</span>
<span class="nc" id="L706">      seenObjects.remove(datum);</span>
    } else {
<span class="nc" id="L708">      buffer.append(datum);</span>
    }
<span class="nc" id="L710">  }</span>

  /* Adapted from https://code.google.com/p/json-simple */
  private static void writeEscapedString(CharSequence string, StringBuilder builder) {
<span class="nc bnc" id="L714" title="All 2 branches missed.">    for (int i = 0; i &lt; string.length(); i++) {</span>
<span class="nc" id="L715">      char ch = string.charAt(i);</span>
<span class="nc bnc" id="L716" title="All 8 branches missed.">      switch (ch) {</span>
      case '&quot;':
<span class="nc" id="L718">        builder.append(&quot;\\\&quot;&quot;);</span>
<span class="nc" id="L719">        break;</span>
      case '\\':
<span class="nc" id="L721">        builder.append(&quot;\\\\&quot;);</span>
<span class="nc" id="L722">        break;</span>
      case '\b':
<span class="nc" id="L724">        builder.append(&quot;\\b&quot;);</span>
<span class="nc" id="L725">        break;</span>
      case '\f':
<span class="nc" id="L727">        builder.append(&quot;\\f&quot;);</span>
<span class="nc" id="L728">        break;</span>
      case '\n':
<span class="nc" id="L730">        builder.append(&quot;\\n&quot;);</span>
<span class="nc" id="L731">        break;</span>
      case '\r':
<span class="nc" id="L733">        builder.append(&quot;\\r&quot;);</span>
<span class="nc" id="L734">        break;</span>
      case '\t':
<span class="nc" id="L736">        builder.append(&quot;\\t&quot;);</span>
<span class="nc" id="L737">        break;</span>
      default:
        // Reference: https://www.unicode.org/versions/Unicode5.1.0/
<span class="nc bnc" id="L740" title="All 12 branches missed.">        if ((ch &gt;= '\u0000' &amp;&amp; ch &lt;= '\u001F') || (ch &gt;= '\u007F' &amp;&amp; ch &lt;= '\u009F')</span>
            || (ch &gt;= '\u2000' &amp;&amp; ch &lt;= '\u20FF')) {
<span class="nc" id="L742">          String hex = Integer.toHexString(ch);</span>
<span class="nc" id="L743">          builder.append(&quot;\\u&quot;);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">          for (int j = 0; j &lt; 4 - hex.length(); j++)</span>
<span class="nc" id="L745">            builder.append('0');</span>
<span class="nc" id="L746">          builder.append(hex.toUpperCase());</span>
<span class="nc" id="L747">        } else {</span>
<span class="nc" id="L748">          builder.append(ch);</span>
        }
      }
    }
<span class="nc" id="L752">  }</span>

  /** Create a schema given an example datum. */
  public Schema induce(Object datum) {
<span class="nc bnc" id="L756" title="All 2 branches missed.">    if (isRecord(datum)) {</span>
<span class="nc" id="L757">      return getRecordSchema(datum);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">    } else if (isArray(datum)) {</span>
<span class="nc" id="L759">      Schema elementType = null;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">      for (Object element : getArrayAsCollection(datum)) {</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (elementType == null) {</span>
<span class="nc" id="L762">          elementType = induce(element);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">        } else if (!elementType.equals(induce(element))) {</span>
<span class="nc" id="L764">          throw new AvroTypeException(&quot;No mixed type arrays.&quot;);</span>
        }
<span class="nc" id="L766">      }</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">      if (elementType == null) {</span>
<span class="nc" id="L768">        throw new AvroTypeException(&quot;Empty array: &quot; + datum);</span>
      }
<span class="nc" id="L770">      return Schema.createArray(elementType);</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">    } else if (isMap(datum)) {</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L774">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc" id="L775">      Schema value = null;</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L778">          value = induce(entry.getValue());</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        } else if (!value.equals(induce(entry.getValue()))) {</span>
<span class="nc" id="L780">          throw new AvroTypeException(&quot;No mixed type map values.&quot;);</span>
        }
<span class="nc" id="L782">      }</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L784">        throw new AvroTypeException(&quot;Empty map: &quot; + datum);</span>
      }
<span class="nc" id="L786">      return Schema.createMap(value);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">    } else if (datum instanceof GenericFixed) {</span>
<span class="nc" id="L788">      return Schema.createFixed(null, null, null, ((GenericFixed) datum).bytes().length);</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">    } else if (isString(datum))</span>
<span class="nc" id="L790">      return Schema.create(Type.STRING);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">    else if (isBytes(datum))</span>
<span class="nc" id="L792">      return Schema.create(Type.BYTES);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">    else if (isInteger(datum))</span>
<span class="nc" id="L794">      return Schema.create(Type.INT);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">    else if (isLong(datum))</span>
<span class="nc" id="L796">      return Schema.create(Type.LONG);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">    else if (isFloat(datum))</span>
<span class="nc" id="L798">      return Schema.create(Type.FLOAT);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">    else if (isDouble(datum))</span>
<span class="nc" id="L800">      return Schema.create(Type.DOUBLE);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">    else if (isBoolean(datum))</span>
<span class="nc" id="L802">      return Schema.create(Type.BOOLEAN);</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">    else if (datum == null)</span>
<span class="nc" id="L804">      return Schema.create(Type.NULL);</span>

    else
<span class="nc" id="L807">      throw new AvroTypeException(&quot;Can't create schema for: &quot; + datum);</span>
  }

  /**
   * Called by {@link GenericDatumReader#readRecord} to set a record fields value
   * to a record instance. The default implementation is for
   * {@link IndexedRecord}.
   */
  public void setField(Object record, String name, int position, Object value) {
<span class="nc" id="L816">    ((IndexedRecord) record).put(position, value);</span>
<span class="nc" id="L817">  }</span>

  /**
   * Called by {@link GenericDatumReader#readRecord} to retrieve a record field
   * value from a reused instance. The default implementation is for
   * {@link IndexedRecord}.
   */
  public Object getField(Object record, String name, int position) {
<span class="fc" id="L825">    return ((IndexedRecord) record).get(position);</span>
  }

  /**
   * Produce state for repeated calls to
   * {@link #getField(Object,String,int,Object)} and
   * {@link #setField(Object,String,int,Object,Object)} on the same record.
   */
  protected Object getRecordState(Object record, Schema schema) {
<span class="nc" id="L834">    return null;</span>
  }

  /** Version of {@link #setField} that has state. */
  protected void setField(Object record, String name, int position, Object value, Object state) {
<span class="nc" id="L839">    setField(record, name, position, value);</span>
<span class="nc" id="L840">  }</span>

  /** Version of {@link #getField} that has state. */
  protected Object getField(Object record, String name, int pos, Object state) {
<span class="nc" id="L844">    return getField(record, name, pos);</span>
  }

  /**
   * Return the index for a datum within a union. Implemented with
   * {@link Schema#getIndexNamed(String)} and {@link #getSchemaName(Object)}.
   */
  public int resolveUnion(Schema union, Object datum) {
    // if there is a logical type that works, use it first
    // this allows logical type concrete classes to overlap with supported ones
    // for example, a conversion could return a map
<span class="fc bfc" id="L855" title="All 2 branches covered.">    if (datum != null) {</span>
<span class="fc" id="L856">      Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datum.getClass());</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">      if (conversions != null) {</span>
<span class="nc" id="L858">        List&lt;Schema&gt; candidates = union.getTypes();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">        for (int i = 0; i &lt; candidates.size(); i += 1) {</span>
<span class="nc" id="L860">          LogicalType candidateType = candidates.get(i).getLogicalType();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">          if (candidateType != null) {</span>
<span class="nc" id="L862">            Conversion&lt;?&gt; conversion = conversions.get(candidateType.getName());</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (conversion != null) {</span>
<span class="nc" id="L864">              return i;</span>
            }
          }
        }
      }
    }

<span class="fc" id="L871">    Integer i = union.getIndexNamed(getSchemaName(datum));</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">    if (i != null) {</span>
<span class="fc" id="L873">      return i;</span>
    }
<span class="nc" id="L875">    throw new UnresolvedUnionException(union, datum);</span>
  }

  /**
   * Return the schema full name for a datum. Called by
   * {@link #resolveUnion(Schema,Object)}.
   */
  protected String getSchemaName(Object datum) {
<span class="pc bpc" id="L883" title="1 of 4 branches missed.">    if (datum == null || datum == JsonProperties.NULL_VALUE)</span>
<span class="fc" id="L884">      return Type.NULL.getName();</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">    if (isRecord(datum))</span>
<span class="nc" id="L886">      return getRecordSchema(datum).getFullName();</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">    if (isEnum(datum))</span>
<span class="nc" id="L888">      return getEnumSchema(datum).getFullName();</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">    if (isArray(datum))</span>
<span class="nc" id="L890">      return Type.ARRAY.getName();</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">    if (isMap(datum))</span>
<span class="nc" id="L892">      return Type.MAP.getName();</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">    if (isFixed(datum))</span>
<span class="nc" id="L894">      return getFixedSchema(datum).getFullName();</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">    if (isString(datum))</span>
<span class="nc" id="L896">      return Type.STRING.getName();</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">    if (isBytes(datum))</span>
<span class="nc" id="L898">      return Type.BYTES.getName();</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">    if (isInteger(datum))</span>
<span class="fc" id="L900">      return Type.INT.getName();</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">    if (isLong(datum))</span>
<span class="nc" id="L902">      return Type.LONG.getName();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">    if (isFloat(datum))</span>
<span class="nc" id="L904">      return Type.FLOAT.getName();</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">    if (isDouble(datum))</span>
<span class="nc" id="L906">      return Type.DOUBLE.getName();</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">    if (isBoolean(datum))</span>
<span class="nc" id="L908">      return Type.BOOLEAN.getName();</span>
<span class="nc" id="L909">    throw new AvroRuntimeException(String.format(&quot;Unknown datum type %s: %s&quot;, datum.getClass().getName(), datum));</span>
  }

  /**
   * Called by {@link #resolveUnion(Schema,Object)}. May be overridden for
   * alternate data representations.
   */
  protected boolean instanceOf(Schema schema, Object datum) {
<span class="nc bnc" id="L917" title="All 14 branches missed.">    switch (schema.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L919" title="All 2 branches missed.">      if (!isRecord(datum))</span>
<span class="nc" id="L920">        return false;</span>
<span class="nc bnc" id="L921" title="All 4 branches missed.">      return (schema.getFullName() == null) ? getRecordSchema(datum).getFullName() == null</span>
<span class="nc" id="L922">          : schema.getFullName().equals(getRecordSchema(datum).getFullName());</span>
    case ENUM:
<span class="nc bnc" id="L924" title="All 2 branches missed.">      if (!isEnum(datum))</span>
<span class="nc" id="L925">        return false;</span>
<span class="nc" id="L926">      return schema.getFullName().equals(getEnumSchema(datum).getFullName());</span>
    case ARRAY:
<span class="nc" id="L928">      return isArray(datum);</span>
    case MAP:
<span class="nc" id="L930">      return isMap(datum);</span>
    case FIXED:
<span class="nc bnc" id="L932" title="All 2 branches missed.">      if (!isFixed(datum))</span>
<span class="nc" id="L933">        return false;</span>
<span class="nc" id="L934">      return schema.getFullName().equals(getFixedSchema(datum).getFullName());</span>
    case STRING:
<span class="nc" id="L936">      return isString(datum);</span>
    case BYTES:
<span class="nc" id="L938">      return isBytes(datum);</span>
    case INT:
<span class="nc" id="L940">      return isInteger(datum);</span>
    case LONG:
<span class="nc" id="L942">      return isLong(datum);</span>
    case FLOAT:
<span class="nc" id="L944">      return isFloat(datum);</span>
    case DOUBLE:
<span class="nc" id="L946">      return isDouble(datum);</span>
    case BOOLEAN:
<span class="nc" id="L948">      return isBoolean(datum);</span>
    case NULL:
<span class="nc bnc" id="L950" title="All 2 branches missed.">      return datum == null;</span>
    default:
<span class="nc" id="L952">      throw new AvroRuntimeException(&quot;Unexpected type: &quot; + schema);</span>
    }
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isArray(Object datum) {
<span class="fc" id="L958">    return datum instanceof Collection;</span>
  }

  /** Called to access an array as a collection. */
  protected Collection getArrayAsCollection(Object datum) {
<span class="fc" id="L963">    return (Collection) datum;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isRecord(Object datum) {
<span class="fc" id="L968">    return datum instanceof IndexedRecord;</span>
  }

  /**
   * Called to obtain the schema of a record. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate record
   * representations.
   */
  protected Schema getRecordSchema(Object record) {
<span class="nc" id="L977">    return ((GenericContainer) record).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isEnum(Object datum) {
<span class="fc" id="L982">    return datum instanceof GenericEnumSymbol;</span>
  }

  /**
   * Called to obtain the schema of a enum. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate enum
   * representations.
   */
  protected Schema getEnumSchema(Object enu) {
<span class="nc" id="L991">    return ((GenericContainer) enu).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isMap(Object datum) {
<span class="fc" id="L996">    return datum instanceof Map;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isFixed(Object datum) {
<span class="fc" id="L1001">    return datum instanceof GenericFixed;</span>
  }

  /**
   * Called to obtain the schema of a fixed. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate fixed
   * representations.
   */
  protected Schema getFixedSchema(Object fixed) {
<span class="nc" id="L1010">    return ((GenericContainer) fixed).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isString(Object datum) {
<span class="fc" id="L1015">    return datum instanceof CharSequence;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isBytes(Object datum) {
<span class="fc" id="L1020">    return datum instanceof ByteBuffer;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isInteger(Object datum) {
<span class="fc" id="L1027">    return datum instanceof Integer;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isLong(Object datum) {
<span class="fc" id="L1034">    return datum instanceof Long;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isFloat(Object datum) {
<span class="fc" id="L1041">    return datum instanceof Float;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isDouble(Object datum) {
<span class="fc" id="L1048">    return datum instanceof Double;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isBoolean(Object datum) {
<span class="fc" id="L1055">    return datum instanceof Boolean;</span>
  }

  /**
   * Compute a hash code according to a schema, consistent with
   * {@link #compare(Object,Object,Schema)}.
   */
  public int hashCode(Object o, Schema s) {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">    if (o == null)</span>
<span class="nc" id="L1064">      return 0; // incomplete datum</span>
<span class="nc" id="L1065">    int hashCode = 1;</span>
<span class="nc bnc" id="L1066" title="All 7 branches missed.">    switch (s.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L1068" title="All 2 branches missed.">      for (Field f : s.getFields()) {</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (f.order() == Field.Order.IGNORE)</span>
<span class="nc" id="L1070">          continue;</span>
<span class="nc" id="L1071">        hashCode = hashCodeAdd(hashCode, getField(o, f.name(), f.pos()), f.schema());</span>
<span class="nc" id="L1072">      }</span>
<span class="nc" id="L1073">      return hashCode;</span>
    case ARRAY:
<span class="nc" id="L1075">      Collection&lt;?&gt; a = (Collection&lt;?&gt;) o;</span>
<span class="nc" id="L1076">      Schema elementType = s.getElementType();</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">      for (Object e : a)</span>
<span class="nc" id="L1078">        hashCode = hashCodeAdd(hashCode, e, elementType);</span>
<span class="nc" id="L1079">      return hashCode;</span>
    case UNION:
<span class="nc" id="L1081">      return hashCode(o, s.getTypes().get(resolveUnion(s, o)));</span>
    case ENUM:
<span class="nc" id="L1083">      return s.getEnumOrdinal(o.toString());</span>
    case NULL:
<span class="nc" id="L1085">      return 0;</span>
    case STRING:
<span class="nc bnc" id="L1087" title="All 2 branches missed.">      return (o instanceof Utf8 ? o : new Utf8(o.toString())).hashCode();</span>
    default:
<span class="nc" id="L1089">      return o.hashCode();</span>
    }
  }

  /** Add the hash code for an object into an accumulated hash code. */
  protected int hashCodeAdd(int hashCode, Object o, Schema s) {
<span class="nc" id="L1095">    return 31 * hashCode + hashCode(o, s);</span>
  }

  /**
   * Compare objects according to their schema. If equal, return zero. If
   * greater-than, return 1, if less than return -1. Order is consistent with that
   * of {@link BinaryData#compare(byte[], int, byte[], int, Schema)}.
   */
  public int compare(Object o1, Object o2, Schema s) {
<span class="fc" id="L1104">    return compare(o1, o2, s, false);</span>
  }

  /**
   * Comparison implementation. When equals is true, only checks for equality, not
   * for order.
   */
  @SuppressWarnings(value = &quot;unchecked&quot;)
  protected int compare(Object o1, Object o2, Schema s, boolean equals) {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">    if (o1 == o2)</span>
<span class="fc" id="L1114">      return 0;</span>
<span class="pc bpc" id="L1115" title="2 of 8 branches missed.">    switch (s.getType()) {</span>
    case RECORD:
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">      for (Field f : s.getFields()) {</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">        if (f.order() == Field.Order.IGNORE)</span>
<span class="nc" id="L1119">          continue; // ignore this field</span>
<span class="fc" id="L1120">        int pos = f.pos();</span>
<span class="fc" id="L1121">        String name = f.name();</span>
<span class="fc" id="L1122">        int compare = compare(getField(o1, name, pos), getField(o2, name, pos), f.schema(), equals);</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (compare != 0) // not equal</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">          return f.order() == Field.Order.DESCENDING ? -compare : compare;</span>
<span class="nc" id="L1125">      }</span>
<span class="nc" id="L1126">      return 0;</span>
    case ENUM:
<span class="fc" id="L1128">      return s.getEnumOrdinal(o1.toString()) - s.getEnumOrdinal(o2.toString());</span>
    case ARRAY:
<span class="fc" id="L1130">      Collection a1 = (Collection) o1;</span>
<span class="fc" id="L1131">      Collection a2 = (Collection) o2;</span>
<span class="fc" id="L1132">      Iterator e1 = a1.iterator();</span>
<span class="fc" id="L1133">      Iterator e2 = a2.iterator();</span>
<span class="fc" id="L1134">      Schema elementType = s.getElementType();</span>
<span class="pc bpc" id="L1135" title="2 of 4 branches missed.">      while (e1.hasNext() &amp;&amp; e2.hasNext()) {</span>
<span class="fc" id="L1136">        int compare = compare(e1.next(), e2.next(), elementType, equals);</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        if (compare != 0)</span>
<span class="fc" id="L1138">          return compare;</span>
<span class="fc" id="L1139">      }</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">      return e1.hasNext() ? 1 : (e2.hasNext() ? -1 : 0);</span>
    case MAP:
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">      if (equals)</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        return o1.equals(o2) ? 0 : 1;</span>
<span class="fc" id="L1144">      throw new AvroRuntimeException(&quot;Can't compare maps!&quot;);</span>
    case UNION:
<span class="fc" id="L1146">      int i1 = resolveUnion(s, o1);</span>
<span class="fc" id="L1147">      int i2 = resolveUnion(s, o2);</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">      return (i1 == i2) ? compare(o1, o2, s.getTypes().get(i1), equals) : Integer.compare(i1, i2);</span>
    case NULL:
<span class="nc" id="L1150">      return 0;</span>
    case STRING:
<span class="nc bnc" id="L1152" title="All 2 branches missed.">      Utf8 u1 = o1 instanceof Utf8 ? (Utf8) o1 : new Utf8(o1.toString());</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">      Utf8 u2 = o2 instanceof Utf8 ? (Utf8) o2 : new Utf8(o2.toString());</span>
<span class="nc" id="L1154">      return u1.compareTo(u2);</span>
    default:
<span class="fc" id="L1156">      return ((Comparable) o1).compareTo(o2);</span>
    }
  }

<span class="fc" id="L1160">  private final Map&lt;Field, Object&gt; defaultValueCache = Collections.synchronizedMap(new WeakHashMap&lt;&gt;());</span>

  /**
   * Gets the default value of the given field, if any.
   *
   * @param field the field whose default value should be retrieved.
   * @return the default value associated with the given field, or null if none is
   *         specified in the schema.
   */
  @SuppressWarnings({ &quot;unchecked&quot; })
  public Object getDefaultValue(Field field) {
<span class="nc" id="L1171">    JsonNode json = Accessor.defaultValue(field);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">    if (json == null)</span>
<span class="nc" id="L1173">      throw new AvroMissingFieldException(&quot;Field &quot; + field + &quot; not set and has no default value&quot;, field);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">    if (json.isNull() &amp;&amp; (field.schema().getType() == Type.NULL</span>
<span class="nc bnc" id="L1175" title="All 4 branches missed.">        || (field.schema().getType() == Type.UNION &amp;&amp; field.schema().getTypes().get(0).getType() == Type.NULL))) {</span>
<span class="nc" id="L1176">      return null;</span>
    }

    // Check the cache
<span class="nc" id="L1180">    Object defaultValue = defaultValueCache.get(field);</span>

    // If not cached, get the default Java value by encoding the default JSON
    // value and then decoding it:
<span class="nc bnc" id="L1184" title="All 2 branches missed.">    if (defaultValue == null)</span>
      try {
<span class="nc" id="L1186">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1187">        BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(baos, null);</span>
<span class="nc" id="L1188">        Accessor.encode(encoder, field.schema(), json);</span>
<span class="nc" id="L1189">        encoder.flush();</span>
<span class="nc" id="L1190">        BinaryDecoder decoder = DecoderFactory.get().binaryDecoder(baos.toByteArray(), null);</span>
<span class="nc" id="L1191">        defaultValue = createDatumReader(field.schema()).read(null, decoder);</span>

        // this MAY result in two threads creating the same defaultValue
        // and calling put. The last thread will win. However,
        // that's not an issue.
<span class="nc" id="L1196">        defaultValueCache.put(field, defaultValue);</span>
<span class="nc" id="L1197">      } catch (IOException e) {</span>
<span class="nc" id="L1198">        throw new AvroRuntimeException(e);</span>
<span class="nc" id="L1199">      }</span>

<span class="nc" id="L1201">    return defaultValue;</span>
  }

<span class="fc" id="L1204">  private static final Schema STRINGS = Schema.create(Type.STRING);</span>

  /**
   * Makes a deep copy of a value given its schema.
   * &lt;P&gt;
   * Logical types are converted to raw types, copied, then converted back.
   *
   * @param schema the schema of the value to deep copy.
   * @param value  the value to deep copy.
   * @return a deep copy of the given value.
   */
  @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
  public &lt;T&gt; T deepCopy(Schema schema, T value) {
<span class="nc bnc" id="L1217" title="All 2 branches missed.">    if (value == null)</span>
<span class="nc" id="L1218">      return null;</span>
<span class="nc" id="L1219">    LogicalType logicalType = schema.getLogicalType();</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">    if (logicalType == null) // not a logical type -- use raw copy</span>
<span class="nc" id="L1221">      return (T) deepCopyRaw(schema, value);</span>
<span class="nc" id="L1222">    Conversion conversion = getConversionByClass(value.getClass(), logicalType);</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    if (conversion == null) // no conversion defined -- try raw copy</span>
<span class="nc" id="L1224">      return (T) deepCopyRaw(schema, value);</span>
    // logical type with conversion: convert to raw, copy, then convert back to
    // logical
<span class="nc" id="L1227">    Object raw = Conversions.convertToRawType(value, schema, logicalType, conversion);</span>
<span class="nc" id="L1228">    Object copy = deepCopyRaw(schema, raw); // copy raw</span>
<span class="nc" id="L1229">    return (T) Conversions.convertToLogicalType(copy, schema, logicalType, conversion);</span>
  }

  private Object deepCopyRaw(Schema schema, Object value) {
<span class="nc bnc" id="L1233" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L1234">      return null;</span>
    }

<span class="nc bnc" id="L1237" title="All 15 branches missed.">    switch (schema.getType()) {</span>
    case ARRAY:
<span class="nc" id="L1239">      List&lt;Object&gt; arrayValue = (List) value;</span>
<span class="nc" id="L1240">      List&lt;Object&gt; arrayCopy = new GenericData.Array&lt;&gt;(arrayValue.size(), schema);</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">      for (Object obj : arrayValue) {</span>
<span class="nc" id="L1242">        arrayCopy.add(deepCopy(schema.getElementType(), obj));</span>
<span class="nc" id="L1243">      }</span>
<span class="nc" id="L1244">      return arrayCopy;</span>
    case BOOLEAN:
<span class="nc" id="L1246">      return value; // immutable</span>
    case BYTES:
<span class="nc" id="L1248">      ByteBuffer byteBufferValue = (ByteBuffer) value;</span>
<span class="nc" id="L1249">      int start = byteBufferValue.position();</span>
<span class="nc" id="L1250">      int length = byteBufferValue.limit() - start;</span>
<span class="nc" id="L1251">      byte[] bytesCopy = new byte[length];</span>
<span class="nc" id="L1252">      byteBufferValue.get(bytesCopy, 0, length);</span>
<span class="nc" id="L1253">      byteBufferValue.position(start);</span>
<span class="nc" id="L1254">      return ByteBuffer.wrap(bytesCopy, 0, length);</span>
    case DOUBLE:
<span class="nc" id="L1256">      return value; // immutable</span>
    case ENUM:
<span class="nc" id="L1258">      return createEnum(value.toString(), schema);</span>
    case FIXED:
<span class="nc" id="L1260">      return createFixed(null, ((GenericFixed) value).bytes(), schema);</span>
    case FLOAT:
<span class="nc" id="L1262">      return value; // immutable</span>
    case INT:
<span class="nc" id="L1264">      return value; // immutable</span>
    case LONG:
<span class="nc" id="L1266">      return value; // immutable</span>
    case MAP:
<span class="nc" id="L1268">      Map&lt;CharSequence, Object&gt; mapValue = (Map) value;</span>
<span class="nc" id="L1269">      Map&lt;CharSequence, Object&gt; mapCopy = new HashMap&lt;&gt;(mapValue.size());</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">      for (Map.Entry&lt;CharSequence, Object&gt; entry : mapValue.entrySet()) {</span>
<span class="nc" id="L1271">        mapCopy.put(deepCopy(STRINGS, entry.getKey()), deepCopy(schema.getValueType(), entry.getValue()));</span>
<span class="nc" id="L1272">      }</span>
<span class="nc" id="L1273">      return mapCopy;</span>
    case NULL:
<span class="nc" id="L1275">      return null;</span>
    case RECORD:
<span class="nc" id="L1277">      Object oldState = getRecordState(value, schema);</span>
<span class="nc" id="L1278">      Object newRecord = newRecord(null, schema);</span>
<span class="nc" id="L1279">      Object newState = getRecordState(newRecord, schema);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">      for (Field f : schema.getFields()) {</span>
<span class="nc" id="L1281">        int pos = f.pos();</span>
<span class="nc" id="L1282">        String name = f.name();</span>
<span class="nc" id="L1283">        Object newValue = deepCopy(f.schema(), getField(value, name, pos, oldState));</span>
<span class="nc" id="L1284">        setField(newRecord, name, pos, newValue, newState);</span>
<span class="nc" id="L1285">      }</span>
<span class="nc" id="L1286">      return newRecord;</span>
    case STRING:
      // Strings are immutable
<span class="nc bnc" id="L1289" title="All 2 branches missed.">      if (value instanceof String) {</span>
<span class="nc" id="L1290">        return value;</span>
      }

      // Some CharSequence subclasses are mutable, so we still need to make
      // a copy
<span class="nc bnc" id="L1295" title="All 2 branches missed.">      else if (value instanceof Utf8) {</span>
        // Utf8 copy constructor is more efficient than converting
        // to string and then back to Utf8
<span class="nc" id="L1298">        return new Utf8((Utf8) value);</span>
      }
<span class="nc" id="L1300">      return new Utf8(value.toString());</span>
    case UNION:
<span class="nc" id="L1302">      return deepCopy(schema.getTypes().get(resolveUnion(schema, value)), value);</span>
    default:
<span class="nc" id="L1304">      throw new AvroRuntimeException(&quot;Deep copy failed for schema \&quot;&quot; + schema + &quot;\&quot; and value \&quot;&quot; + value + &quot;\&quot;&quot;);</span>
    }
  }

  /**
   * Called to create an fixed value. May be overridden for alternate fixed
   * representations. By default, returns {@link GenericFixed}.
   */
  public Object createFixed(Object old, Schema schema) {
<span class="nc bnc" id="L1313" title="All 4 branches missed.">    if ((old instanceof GenericFixed) &amp;&amp; ((GenericFixed) old).bytes().length == schema.getFixedSize())</span>
<span class="nc" id="L1314">      return old;</span>
<span class="nc" id="L1315">    return new GenericData.Fixed(schema);</span>
  }

  /**
   * Called to create an fixed value. May be overridden for alternate fixed
   * representations. By default, returns {@link GenericFixed}.
   */
  public Object createFixed(Object old, byte[] bytes, Schema schema) {
<span class="nc" id="L1323">    GenericFixed fixed = (GenericFixed) createFixed(old, schema);</span>
<span class="nc" id="L1324">    System.arraycopy(bytes, 0, fixed.bytes(), 0, schema.getFixedSize());</span>
<span class="nc" id="L1325">    return fixed;</span>
  }

  /**
   * Called to create an enum value. May be overridden for alternate enum
   * representations. By default, returns a GenericEnumSymbol.
   */
  public Object createEnum(String symbol, Schema schema) {
<span class="nc" id="L1333">    return new EnumSymbol(schema, symbol);</span>
  }

  /**
   * Called to create new record instances. Subclasses may override to use a
   * different record implementation. The returned instance must conform to the
   * schema provided. If the old object contains fields not present in the schema,
   * they should either be removed from the old object, or it should create a new
   * instance that conforms to the schema. By default, this returns a
   * {@link GenericData.Record}.
   */
  public Object newRecord(Object old, Schema schema) {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">    if (old instanceof IndexedRecord) {</span>
<span class="nc" id="L1346">      IndexedRecord record = (IndexedRecord) old;</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">      if (record.getSchema() == schema)</span>
<span class="nc" id="L1348">        return record;</span>
    }
<span class="nc" id="L1350">    return new GenericData.Record(schema);</span>
  }

  /**
   * Called to create new array instances. Subclasses may override to use a
   * different array implementation. By default, this returns a
   * {@link GenericData.Array}.
   */
  public Object newArray(Object old, int size, Schema schema) {
<span class="nc bnc" id="L1359" title="All 2 branches missed.">    if (old instanceof GenericArray) {</span>
<span class="nc" id="L1360">      ((GenericArray&lt;?&gt;) old).reset();</span>
<span class="nc" id="L1361">      return old;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">    } else if (old instanceof Collection) {</span>
<span class="nc" id="L1363">      ((Collection&lt;?&gt;) old).clear();</span>
<span class="nc" id="L1364">      return old;</span>
    } else
<span class="nc" id="L1366">      return new GenericData.Array&lt;Object&gt;(size, schema);</span>
  }

  /**
   * Called to create new array instances. Subclasses may override to use a
   * different map implementation. By default, this returns a {@link HashMap}.
   */
  public Object newMap(Object old, int size) {
<span class="nc bnc" id="L1374" title="All 2 branches missed.">    if (old instanceof Map) {</span>
<span class="nc" id="L1375">      ((Map&lt;?, ?&gt;) old).clear();</span>
<span class="nc" id="L1376">      return old;</span>
    } else
<span class="nc" id="L1378">      return new HashMap&lt;&gt;(size);</span>
  }

  /**
   * create a supplier that allows to get new record instances for a given schema
   * in an optimized way
   */
  public InstanceSupplier getNewRecordSupplier(Schema schema) {
<span class="nc" id="L1386">    return this::newRecord;</span>
  }

  public interface InstanceSupplier {
    public Object newInstance(Object oldInstance, Schema schema);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>