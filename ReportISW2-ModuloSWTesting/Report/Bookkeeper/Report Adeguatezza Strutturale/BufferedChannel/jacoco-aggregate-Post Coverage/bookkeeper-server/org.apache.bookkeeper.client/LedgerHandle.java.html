<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LedgerHandle.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Test-coverage</a> &gt; <a href="../index.html" class="el_bundle">bookkeeper-server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerHandle.java</span></div><h1>LedgerHandle.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkState;
import static org.apache.bookkeeper.client.api.BKException.Code.ClientClosedException;
import static org.apache.bookkeeper.client.api.BKException.Code.WriteException;

import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.bookkeeper.client.AsyncCallback.AddCallback;
import org.apache.bookkeeper.client.AsyncCallback.AddCallbackWithLatency;
import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;
import org.apache.bookkeeper.client.BKException.BKIncorrectParameterException;
import org.apache.bookkeeper.client.BKException.BKReadException;
import org.apache.bookkeeper.client.DistributionSchedule.WriteSet;
import org.apache.bookkeeper.client.SyncCallbackUtils.FutureReadLastConfirmed;
import org.apache.bookkeeper.client.SyncCallbackUtils.FutureReadLastConfirmedAndEntry;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncAddCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncCloseCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncReadCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncReadLastConfirmedCallback;
import org.apache.bookkeeper.client.api.BKException.Code;
import org.apache.bookkeeper.client.api.LastConfirmedAndEntry;
import org.apache.bookkeeper.client.api.LedgerEntries;
import org.apache.bookkeeper.client.api.LedgerMetadata;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.client.api.WriteHandle;
import org.apache.bookkeeper.client.impl.LedgerEntryImpl;
import org.apache.bookkeeper.common.concurrent.FutureEventListener;
import org.apache.bookkeeper.common.concurrent.FutureUtils;
import org.apache.bookkeeper.common.util.MathUtils;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.checksum.DigestManager;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.util.SafeRunnable;
import org.apache.bookkeeper.versioning.Versioned;
import org.apache.commons.collections4.IteratorUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Iterators;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.RateLimiter;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;

/**
 * Ledger handle contains ledger metadata and is used to access the read and
 * write operations to a ledger.
 */
public class LedgerHandle implements WriteHandle {
<span class="nc" id="L98">	static final Logger LOG = LoggerFactory.getLogger(LedgerHandle.class);</span>

	private static final int STICKY_READ_BOOKIE_INDEX_UNSET = -1;

	final ClientContext clientCtx;

	final byte[] ledgerKey;
	private Versioned&lt;LedgerMetadata&gt; versionedMetadata;
	final long ledgerId;
	long lastAddPushed;

<span class="nc" id="L109">	private enum HandleState {</span>
<span class="nc" id="L110">		OPEN, CLOSED</span>
	}

<span class="nc" id="L113">	private HandleState handleState = HandleState.OPEN;</span>
<span class="nc" id="L114">	private final CompletableFuture&lt;Void&gt; closePromise = new CompletableFuture&lt;&gt;();</span>

	/**
	 * Last entryId which has been confirmed to be written durably to the bookies.
	 * This value is used by readers, the the LAC protocol
	 */
	volatile long lastAddConfirmed;

	/**
	 * Next entryId which is expected to move forward during
	 * {@link #sendAddSuccessCallbacks() }. This is important in order to have an
	 * ordered sequence of addEntry ackknowledged to the writer
	 */
	volatile long pendingAddsSequenceHead;

	/**
	 * If bookie sticky reads are enabled, this will contain the index of the bookie
	 * selected as &quot;sticky&quot; for this ledger. The bookie is chosen at random when the
	 * LedgerHandle is created.
	 *
	 * &lt;p&gt;
	 * In case of failures, the bookie index will be updated (to the next bookie in
	 * the ensemble) to avoid continuing to attempt to read from a failed bookie.
	 *
	 * &lt;p&gt;
	 * If the index is -1, it means the sticky reads are disabled.
	 */
	private int stickyBookieIndex;

	long length;
	final DigestManager macManager;
	final DistributionSchedule distributionSchedule;
	final RateLimiter throttler;
	final LoadingCache&lt;BookieSocketAddress, Long&gt; bookieFailureHistory;
	final BookiesHealthInfo bookiesHealthInfo;
	final EnumSet&lt;WriteFlag&gt; writeFlags;

<span class="nc" id="L151">	ScheduledFuture&lt;?&gt; timeoutFuture = null;</span>

<span class="nc" id="L153">	@VisibleForTesting</span>
	final Map&lt;Integer, BookieSocketAddress&gt; delayedWriteFailedBookies = new HashMap&lt;Integer, BookieSocketAddress&gt;();

	/**
	 * Invalid entry id. This value is returned from methods which should return an
	 * entry id but there is no valid entry available.
	 */
	public static final long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;

	/**
	 * Invalid ledger id. Ledger IDs must be greater than or equal to 0. Large
	 * negative used to make it easy to spot in logs if erroneously used.
	 */
	public static final long INVALID_LEDGER_ID = -0xABCDABCDL;

<span class="nc" id="L168">	final Object metadataLock = new Object();</span>
<span class="nc" id="L169">	boolean changingEnsemble = false;</span>
<span class="nc" id="L170">	final AtomicInteger numEnsembleChanges = new AtomicInteger(0);</span>
	Queue&lt;PendingAddOp&gt; pendingAddOps;
	ExplicitLacFlushPolicy explicitLacFlushPolicy;

	final Counter ensembleChangeCounter;
	final Counter lacUpdateHitsCounter;
	final Counter lacUpdateMissesCounter;
	private final OpStatsLogger clientChannelWriteWaitStats;

	LedgerHandle(ClientContext clientCtx, long ledgerId, Versioned&lt;LedgerMetadata&gt; versionedMetadata,
			BookKeeper.DigestType digestType, byte[] password, EnumSet&lt;WriteFlag&gt; writeFlags)
<span class="nc" id="L181">			throws GeneralSecurityException, NumberFormatException {</span>
<span class="nc" id="L182">		this.clientCtx = clientCtx;</span>

<span class="nc" id="L184">		this.versionedMetadata = versionedMetadata;</span>
<span class="nc" id="L185">		this.pendingAddOps = new ConcurrentLinkedQueue&lt;PendingAddOp&gt;();</span>
<span class="nc" id="L186">		this.writeFlags = writeFlags;</span>

<span class="nc" id="L188">		LedgerMetadata metadata = versionedMetadata.getValue();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">		if (metadata.isClosed()) {</span>
<span class="nc" id="L190">			lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();</span>
<span class="nc" id="L191">			length = metadata.getLength();</span>
		} else {
<span class="nc" id="L193">			lastAddConfirmed = lastAddPushed = INVALID_ENTRY_ID;</span>
<span class="nc" id="L194">			length = 0;</span>
		}

<span class="nc" id="L197">		this.pendingAddsSequenceHead = lastAddConfirmed;</span>

<span class="nc" id="L199">		this.ledgerId = ledgerId;</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">		if (clientCtx.getConf().enableStickyReads</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">				&amp;&amp; getLedgerMetadata().getEnsembleSize() == getLedgerMetadata().getWriteQuorumSize()) {</span>
<span class="nc" id="L203">			stickyBookieIndex = clientCtx.getPlacementPolicy().getStickyReadBookieIndex(metadata, Optional.empty());</span>
		} else {
<span class="nc" id="L205">			stickyBookieIndex = STICKY_READ_BOOKIE_INDEX_UNSET;</span>
		}

<span class="nc bnc" id="L208" title="All 2 branches missed.">		if (clientCtx.getConf().throttleValue &gt; 0) {</span>
<span class="nc" id="L209">			this.throttler = RateLimiter.create(clientCtx.getConf().throttleValue);</span>
		} else {
<span class="nc" id="L211">			this.throttler = null;</span>
		}

<span class="nc" id="L214">		macManager = DigestManager.instantiate(ledgerId, password, BookKeeper.DigestType.toProtoDigestType(digestType),</span>
<span class="nc" id="L215">				clientCtx.getByteBufAllocator(), clientCtx.getConf().useV2WireProtocol);</span>

		// If the password is empty, pass the same random ledger key which is generated
		// by the hash of the empty
		// password, so that the bookie can avoid processing the keys for each entry
<span class="nc" id="L220">		this.ledgerKey = DigestManager.generateMasterKey(password);</span>
<span class="nc" id="L221">		distributionSchedule = new RoundRobinDistributionSchedule(metadata.getWriteQuorumSize(),</span>
<span class="nc" id="L222">				metadata.getAckQuorumSize(), metadata.getEnsembleSize());</span>
<span class="nc" id="L223">		this.bookieFailureHistory = CacheBuilder.newBuilder()</span>
<span class="nc" id="L224">				.expireAfterWrite(clientCtx.getConf().bookieFailureHistoryExpirationMSec, TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L225">				.build(new CacheLoader&lt;BookieSocketAddress, Long&gt;() {</span>
					@Override
					public Long load(BookieSocketAddress key) {
<span class="nc" id="L228">						return -1L;</span>
					}
				});
<span class="nc" id="L231">		this.bookiesHealthInfo = new BookiesHealthInfo() {</span>
			@Override
			public long getBookieFailureHistory(BookieSocketAddress bookieSocketAddress) {
<span class="nc" id="L234">				Long lastFailure = bookieFailureHistory.getIfPresent(bookieSocketAddress);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">				return lastFailure == null ? -1L : lastFailure;</span>
			}

			@Override
			public long getBookiePendingRequests(BookieSocketAddress bookieSocketAddress) {
<span class="nc" id="L240">				return clientCtx.getBookieClient().getNumPendingRequests(bookieSocketAddress, ledgerId);</span>
			}
		};

<span class="nc" id="L244">		ensembleChangeCounter = clientCtx.getClientStats().getEnsembleChangeCounter();</span>
<span class="nc" id="L245">		lacUpdateHitsCounter = clientCtx.getClientStats().getLacUpdateHitsCounter();</span>
<span class="nc" id="L246">		lacUpdateMissesCounter = clientCtx.getClientStats().getLacUpdateMissesCounter();</span>
<span class="nc" id="L247">		clientChannelWriteWaitStats = clientCtx.getClientStats().getClientChannelWriteWaitLogger();</span>

<span class="nc" id="L249">		clientCtx.getClientStats().registerPendingAddsGauge(new Gauge&lt;Integer&gt;() {</span>
			@Override
			public Integer getDefaultValue() {
<span class="nc" id="L252">				return 0;</span>
			}

			@Override
			public Integer getSample() {
<span class="nc" id="L257">				return pendingAddOps.size();</span>
			}
		});

<span class="nc" id="L261">		initializeWriteHandleState();</span>
<span class="nc" id="L262">	}</span>

	/**
	 * Notify the LedgerHandle that a read operation was failed on a particular
	 * bookie.
	 */
	void recordReadErrorOnBookie(int bookieIndex) {
		// If sticky bookie reads are enabled, switch the sticky bookie to the
		// next bookie in the ensemble so that we avoid to keep reading from the
		// same failed bookie
<span class="nc bnc" id="L272" title="All 2 branches missed.">		if (stickyBookieIndex != STICKY_READ_BOOKIE_INDEX_UNSET) {</span>
			// This will be idempotent when we have multiple read errors on the
			// same bookie. The net result is that we just go to the next bookie
<span class="nc" id="L275">			stickyBookieIndex = clientCtx.getPlacementPolicy().getStickyReadBookieIndex(getLedgerMetadata(),</span>
<span class="nc" id="L276">					Optional.of(bookieIndex));</span>
		}
<span class="nc" id="L278">	}</span>

	protected void initializeWriteHandleState() {
<span class="nc bnc" id="L281" title="All 2 branches missed.">		if (clientCtx.getConf().explicitLacInterval &gt; 0) {</span>
<span class="nc" id="L282">			explicitLacFlushPolicy = new ExplicitLacFlushPolicy.ExplicitLacFlushPolicyImpl(this, clientCtx);</span>
		} else {
<span class="nc" id="L284">			explicitLacFlushPolicy = ExplicitLacFlushPolicy.VOID_EXPLICITLAC_FLUSH_POLICY;</span>
		}

<span class="nc bnc" id="L287" title="All 2 branches missed.">		if (clientCtx.getConf().addEntryQuorumTimeoutNanos &gt; 0) {</span>
<span class="nc" id="L288">			SafeRunnable monitor = new SafeRunnable() {</span>
				@Override
				public void safeRun() {
<span class="nc" id="L291">					monitorPendingAddOps();</span>
<span class="nc" id="L292">				}</span>
			};
<span class="nc" id="L294">			this.timeoutFuture = clientCtx.getScheduler().scheduleAtFixedRate(monitor,</span>
<span class="nc" id="L295">					clientCtx.getConf().timeoutMonitorIntervalSec, clientCtx.getConf().timeoutMonitorIntervalSec,</span>
					TimeUnit.SECONDS);
		}
<span class="nc" id="L298">	}</span>

	private void tearDownWriteHandleState() {
<span class="nc" id="L301">		explicitLacFlushPolicy.stopExplicitLacFlush();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (timeoutFuture != null) {</span>
<span class="nc" id="L303">			timeoutFuture.cancel(false);</span>
		}
<span class="nc" id="L305">	}</span>

	/**
	 * Get the id of the current ledger.
	 *
	 * @return the id of the ledger
	 */
	@Override
	public long getId() {
<span class="nc" id="L314">		return ledgerId;</span>
	}

	@VisibleForTesting
	public EnumSet&lt;WriteFlag&gt; getWriteFlags() {
<span class="nc" id="L319">		return writeFlags;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public synchronized long getLastAddConfirmed() {
<span class="nc" id="L327">		return lastAddConfirmed;</span>
	}

	synchronized void setLastAddConfirmed(long lac) {
<span class="nc" id="L331">		this.lastAddConfirmed = lac;</span>
<span class="nc" id="L332">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public synchronized long getLastAddPushed() {
<span class="nc" id="L339">		return lastAddPushed;</span>
	}

	/**
	 * Get the Ledger's key/password.
	 *
	 * @return byte array for the ledger's key/password.
	 */
	public byte[] getLedgerKey() {
<span class="nc" id="L348">		return Arrays.copyOf(ledgerKey, ledgerKey.length);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public LedgerMetadata getLedgerMetadata() {
<span class="nc" id="L356">		return versionedMetadata.getValue();</span>
	}

	Versioned&lt;LedgerMetadata&gt; getVersionedLedgerMetadata() {
<span class="nc" id="L360">		return versionedMetadata;</span>
	}

	boolean setLedgerMetadata(Versioned&lt;LedgerMetadata&gt; expected, Versioned&lt;LedgerMetadata&gt; newMetadata) {
<span class="nc" id="L364">		synchronized (this) {</span>
			// ensure that we only update the metadata if it is the object we expect it to
			// be
<span class="nc bnc" id="L367" title="All 2 branches missed.">			if (versionedMetadata == expected) {</span>
<span class="nc" id="L368">				versionedMetadata = newMetadata;</span>
<span class="nc" id="L369">				LedgerMetadata metadata = versionedMetadata.getValue();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				if (metadata.isClosed()) {</span>
<span class="nc" id="L371">					lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();</span>
<span class="nc" id="L372">					length = metadata.getLength();</span>
				}
<span class="nc" id="L374">				return true;</span>
			} else {
<span class="nc" id="L376">				return false;</span>
			}
		}
	}

	/**
	 * Get this ledger's customMetadata map.
	 *
	 * @return map containing user provided customMetadata.
	 */
	public Map&lt;String, byte[]&gt; getCustomMetadata() {
<span class="nc" id="L387">		return getLedgerMetadata().getCustomMetadata();</span>
	}

	/**
	 * Get the number of fragments that makeup this ledger.
	 *
	 * @return the count of fragments
	 */
	public synchronized long getNumFragments() {
<span class="nc" id="L396">		return getLedgerMetadata().getAllEnsembles().size();</span>
	}

	/**
	 * Get the count of unique bookies that own part of this ledger by going over
	 * all the fragments of the ledger.
	 *
	 * @return count of unique bookies
	 */
	public synchronized long getNumBookies() {
<span class="nc" id="L406">		Map&lt;Long, ? extends List&lt;BookieSocketAddress&gt;&gt; m = getLedgerMetadata().getAllEnsembles();</span>
<span class="nc" id="L407">		Set&lt;BookieSocketAddress&gt; s = Sets.newHashSet();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		for (List&lt;BookieSocketAddress&gt; aList : m.values()) {</span>
<span class="nc" id="L409">			s.addAll(aList);</span>
<span class="nc" id="L410">		}</span>
<span class="nc" id="L411">		return s.size();</span>
	}

	/**
	 * Get the DigestManager.
	 *
	 * @return DigestManager for the LedgerHandle
	 */
	DigestManager getDigestManager() {
<span class="nc" id="L420">		return macManager;</span>
	}

	/**
	 * Add to the length of the ledger in bytes.
	 *
	 * @param delta
	 * @return the length of the ledger after the addition
	 */
	synchronized long addToLength(long delta) {
<span class="nc" id="L430">		this.length += delta;</span>
<span class="nc" id="L431">		return this.length;</span>
	}

	/**
	 * Returns the length of the ledger in bytes.
	 *
	 * @return the length of the ledger in bytes
	 */
	@Override
	public synchronized long getLength() {
<span class="nc" id="L441">		return this.length;</span>
	}

	/**
	 * Returns the ledger creation time.
	 *
	 * @return the ledger creation time
	 */
	public long getCtime() {
<span class="nc" id="L450">		return getLedgerMetadata().getCtime();</span>
	}

	/**
	 * Get the Distribution Schedule.
	 *
	 * @return DistributionSchedule for the LedgerHandle
	 */
	DistributionSchedule getDistributionSchedule() {
<span class="nc" id="L459">		return distributionSchedule;</span>
	}

	/**
	 * Get the health info for bookies for this ledger.
	 *
	 * @return BookiesHealthInfo for every bookie in the write set.
	 */
	BookiesHealthInfo getBookiesHealthInfo() {
<span class="nc" id="L468">		return bookiesHealthInfo;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void close() throws InterruptedException, BKException {
<span class="nc" id="L476">		SyncCallbackUtils.waitForResult(closeAsync());</span>
<span class="nc" id="L477">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;Void&gt; closeAsync() {
<span class="nc" id="L484">		CompletableFuture&lt;Void&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L485">		SyncCloseCallback callback = new SyncCloseCallback(result);</span>
<span class="nc" id="L486">		asyncClose(callback, null);</span>
<span class="nc" id="L487">		return result;</span>
	}

	/**
	 * Asynchronous close, any adds in flight will return errors.
	 *
	 * &lt;p&gt;
	 * Closing a ledger will ensure that all clients agree on what the last entry of
	 * the ledger is. This ensures that, once the ledger has been closed, all reads
	 * from the ledger will return the same set of entries.
	 *
	 * @param cb  callback implementation
	 * @param ctx control object
	 */
	public void asyncClose(CloseCallback cb, Object ctx) {
<span class="nc" id="L502">		asyncCloseInternal(cb, ctx, BKException.Code.LedgerClosedException);</span>
<span class="nc" id="L503">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public synchronized boolean isClosed() {
<span class="nc" id="L510">		return getLedgerMetadata().isClosed();</span>
	}

	boolean isHandleWritable() {
<span class="nc bnc" id="L514" title="All 4 branches missed.">		return !getLedgerMetadata().isClosed() &amp;&amp; handleState == HandleState.OPEN;</span>
	}

	void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {
		try {
<span class="nc" id="L519">			doAsyncCloseInternal(cb, ctx, rc);</span>
<span class="nc" id="L520">		} catch (RejectedExecutionException re) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L522">				LOG.debug(&quot;Failed to close ledger {} : &quot;, ledgerId, re);</span>
			}
<span class="nc" id="L524">			errorOutPendingAdds(BookKeeper.getReturnRc(clientCtx.getBookieClient(), rc));</span>
<span class="nc" id="L525">			cb.closeComplete(BookKeeper.getReturnRc(clientCtx.getBookieClient(), BKException.Code.InterruptedException),</span>
					this, ctx);
<span class="nc" id="L527">		}</span>
<span class="nc" id="L528">	}</span>

	/**
	 * Same as public version of asyncClose except that this one takes an additional
	 * parameter which is the return code to hand to all the pending add ops.
	 *
	 * @param cb
	 * @param ctx
	 * @param rc
	 */
	void doAsyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {
<span class="nc" id="L539">		clientCtx.getMainWorkerPool().executeOrdered(ledgerId, new SafeRunnable() {</span>
			@Override
			public void safeRun() {
				final HandleState prevHandleState;
				final List&lt;PendingAddOp&gt; pendingAdds;
				final long lastEntry;
				final long finalLength;

<span class="nc" id="L547">				closePromise.whenComplete((ignore, ex) -&gt; {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">					if (ex != null) {</span>
<span class="nc" id="L549">						cb.closeComplete(</span>
<span class="nc" id="L550">								BKException.getExceptionCode(ex, BKException.Code.UnexpectedConditionException),</span>
								LedgerHandle.this, ctx);
					} else {
<span class="nc" id="L553">						cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);</span>
					}
<span class="nc" id="L555">				});</span>

<span class="nc" id="L557">				synchronized (LedgerHandle.this) {</span>
<span class="nc" id="L558">					prevHandleState = handleState;</span>

					// drain pending adds first
<span class="nc" id="L561">					pendingAdds = drainPendingAddsAndAdjustLength();</span>

					// taking the length must occur after draining, as draining changes the length
<span class="nc" id="L564">					lastEntry = lastAddPushed = LedgerHandle.this.lastAddConfirmed;</span>
<span class="nc" id="L565">					finalLength = LedgerHandle.this.length;</span>
<span class="nc" id="L566">					handleState = HandleState.CLOSED;</span>
<span class="nc" id="L567">				}</span>

				// error out all pending adds during closing, the callbacks shouldn't be
				// running under any bk locks.
<span class="nc" id="L571">				errorOutPendingAdds(rc, pendingAdds);</span>

<span class="nc bnc" id="L573" title="All 2 branches missed.">				if (prevHandleState != HandleState.CLOSED) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">					if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L575">						LOG.debug(&quot;Closing ledger: {} at entryId {} with {} bytes&quot;, getId(), lastEntry, finalLength);</span>
					}

<span class="nc" id="L578">					tearDownWriteHandleState();</span>
<span class="nc" id="L579">					new MetadataUpdateLoop(clientCtx.getLedgerManager(), getId(),</span>
							LedgerHandle.this::getVersionedLedgerMetadata, (metadata) -&gt; {
<span class="nc bnc" id="L581" title="All 2 branches missed.">								if (metadata.isClosed()) {</span>
									/*
									 * If the ledger has been closed with the same lastEntry and length that we
									 * planned to close with, we have nothing to do, so just return success
									 */
<span class="nc bnc" id="L586" title="All 4 branches missed.">									if (lastEntry == metadata.getLastEntryId() &amp;&amp; finalLength == metadata.getLength()) {</span>
<span class="nc" id="L587">										return false;</span>
									} else {
<span class="nc" id="L589">										LOG.error(</span>
												&quot;Metadata conflict when closing ledger {}.&quot;
														+ &quot; Another client may have recovered the ledger while there&quot;
														+ &quot; were writes outstanding. (local lastEntry:{} length:{}) &quot;
														+ &quot; (metadata lastEntry:{} length:{})&quot;,
<span class="nc" id="L594">												getId(), lastEntry, finalLength, metadata.getLastEntryId(),</span>
<span class="nc" id="L595">												metadata.getLength());</span>
<span class="nc" id="L596">										throw new BKException.BKMetadataVersionException();</span>
									}
								} else {
<span class="nc" id="L599">									return true;</span>
								}
							}, (metadata) -&gt; {
<span class="nc" id="L602">								return LedgerMetadataBuilder.from(metadata).withClosedState().withLastEntryId(lastEntry)</span>
<span class="nc" id="L603">										.withLength(finalLength).build();</span>
<span class="nc" id="L604">							}, LedgerHandle.this::setLedgerMetadata).run().whenComplete((metadata, ex) -&gt; {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">								if (ex != null) {</span>
<span class="nc" id="L606">									closePromise.completeExceptionally(ex);</span>
								} else {
<span class="nc" id="L608">									FutureUtils.complete(closePromise, null);</span>
								}
<span class="nc" id="L610">							});</span>
				}
<span class="nc" id="L612">			}</span>
		});
<span class="nc" id="L614">	}</span>

	/**
	 * Read a sequence of entries synchronously.
	 *
	 * @param firstEntry id of first entry of sequence (included)
	 * @param lastEntry  id of last entry of sequence (included)
	 *
	 * @see #asyncReadEntries(long, long, ReadCallback, Object)
	 */
	public Enumeration&lt;LedgerEntry&gt; readEntries(long firstEntry, long lastEntry)
			throws InterruptedException, BKException {
<span class="nc" id="L626">		CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; result = new CompletableFuture&lt;&gt;();</span>

<span class="nc" id="L628">		asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);</span>

<span class="nc" id="L630">		return SyncCallbackUtils.waitForResult(result);</span>
	}

	/**
	 * Read a sequence of entries synchronously, allowing to read after the
	 * LastAddConfirmed range.&lt;br&gt;
	 * This is the same of
	 * {@link #asyncReadUnconfirmedEntries(long, long, ReadCallback, Object) }
	 *
	 * @param firstEntry id of first entry of sequence (included)
	 * @param lastEntry  id of last entry of sequence (included)
	 *
	 * @see #readEntries(long, long)
	 * @see #asyncReadUnconfirmedEntries(long, long, ReadCallback, java.lang.Object)
	 * @see #asyncReadLastConfirmed(ReadLastConfirmedCallback, java.lang.Object)
	 */
	public Enumeration&lt;LedgerEntry&gt; readUnconfirmedEntries(long firstEntry, long lastEntry)
			throws InterruptedException, BKException {
<span class="nc" id="L648">		CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; result = new CompletableFuture&lt;&gt;();</span>

<span class="nc" id="L650">		asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);</span>

<span class="nc" id="L652">		return SyncCallbackUtils.waitForResult(result);</span>
	}

	/**
	 * Read a sequence of entries asynchronously.
	 *
	 * @param firstEntry id of first entry of sequence
	 * @param lastEntry  id of last entry of sequence
	 * @param cb         object implementing read callback interface
	 * @param ctx        control object
	 */
	public void asyncReadEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {
		// Little sanity check
<span class="nc bnc" id="L665" title="All 4 branches missed.">		if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L666">			LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry,</span>
<span class="nc" id="L667">					lastEntry);</span>
<span class="nc" id="L668">			cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);</span>
<span class="nc" id="L669">			return;</span>
		}

<span class="nc bnc" id="L672" title="All 2 branches missed.">		if (lastEntry &gt; lastAddConfirmed) {</span>
<span class="nc" id="L673">			LOG.error(&quot;ReadException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry, lastEntry);</span>
<span class="nc" id="L674">			cb.readComplete(BKException.Code.ReadException, this, null, ctx);</span>
<span class="nc" id="L675">			return;</span>
		}

<span class="nc" id="L678">		asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);</span>
<span class="nc" id="L679">	}</span>

	/**
	 * Read a sequence of entries asynchronously, allowing to read after the
	 * LastAddConfirmed range. &lt;br&gt;
	 * This is the same of
	 * {@link #asyncReadEntries(long, long, ReadCallback, Object) } but it lets the
	 * client read without checking the local value of LastAddConfirmed, so that it
	 * is possibile to read entries for which the writer has not received the
	 * acknowledge yet. &lt;br&gt;
	 * For entries which are within the range 0..LastAddConfirmed BookKeeper
	 * guarantees that the writer has successfully received the acknowledge.&lt;br&gt;
	 * For entries outside that range it is possible that the writer never received
	 * the acknowledge and so there is the risk that the reader is seeing entries
	 * before the writer and this could result in a consistency issue in some
	 * cases.&lt;br&gt;
	 * With this method you can even read entries before the LastAddConfirmed and
	 * entries after it with one call, the expected consistency will be as described
	 * above for each subrange of ids.
	 *
	 * @param firstEntry id of first entry of sequence
	 * @param lastEntry  id of last entry of sequence
	 * @param cb         object implementing read callback interface
	 * @param ctx        control object
	 *
	 * @see #asyncReadEntries(long, long, ReadCallback, Object)
	 * @see #asyncReadLastConfirmed(ReadLastConfirmedCallback, Object)
	 * @see #readUnconfirmedEntries(long, long)
	 */
	public void asyncReadUnconfirmedEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {
		// Little sanity check
<span class="nc bnc" id="L710" title="All 4 branches missed.">		if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L711">			LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry,</span>
<span class="nc" id="L712">					lastEntry);</span>
<span class="nc" id="L713">			cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);</span>
<span class="nc" id="L714">			return;</span>
		}

<span class="nc" id="L717">		asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);</span>
<span class="nc" id="L718">	}</span>

	/**
	 * Read a sequence of entries asynchronously.
	 *
	 * @param firstEntry id of first entry of sequence
	 * @param lastEntry  id of last entry of sequence
	 */
	@Override
	public CompletableFuture&lt;LedgerEntries&gt; readAsync(long firstEntry, long lastEntry) {
		// Little sanity check
<span class="nc bnc" id="L729" title="All 4 branches missed.">		if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L730">			LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry,</span>
<span class="nc" id="L731">					lastEntry);</span>
<span class="nc" id="L732">			return FutureUtils.exception(new BKIncorrectParameterException());</span>
		}

<span class="nc bnc" id="L735" title="All 2 branches missed.">		if (lastEntry &gt; lastAddConfirmed) {</span>
<span class="nc" id="L736">			LOG.error(&quot;ReadException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry, lastEntry);</span>
<span class="nc" id="L737">			return FutureUtils.exception(new BKReadException());</span>
		}

<span class="nc" id="L740">		return readEntriesInternalAsync(firstEntry, lastEntry, false);</span>
	}

	/**
	 * Read a sequence of entries asynchronously, allowing to read after the
	 * LastAddConfirmed range. &lt;br&gt;
	 * This is the same of
	 * {@link #asyncReadEntries(long, long, ReadCallback, Object) } but it lets the
	 * client read without checking the local value of LastAddConfirmed, so that it
	 * is possibile to read entries for which the writer has not received the
	 * acknowledge yet. &lt;br&gt;
	 * For entries which are within the range 0..LastAddConfirmed BookKeeper
	 * guarantees that the writer has successfully received the acknowledge.&lt;br&gt;
	 * For entries outside that range it is possible that the writer never received
	 * the acknowledge and so there is the risk that the reader is seeing entries
	 * before the writer and this could result in a consistency issue in some
	 * cases.&lt;br&gt;
	 * With this method you can even read entries before the LastAddConfirmed and
	 * entries after it with one call, the expected consistency will be as described
	 * above for each subrange of ids.
	 *
	 * @param firstEntry id of first entry of sequence
	 * @param lastEntry  id of last entry of sequence
	 *
	 * @see #asyncReadEntries(long, long, ReadCallback, Object)
	 * @see #asyncReadLastConfirmed(ReadLastConfirmedCallback, Object)
	 * @see #readUnconfirmedEntries(long, long)
	 */
	@Override
	public CompletableFuture&lt;LedgerEntries&gt; readUnconfirmedAsync(long firstEntry, long lastEntry) {
		// Little sanity check
<span class="nc bnc" id="L771" title="All 4 branches missed.">		if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L772">			LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;, ledgerId, firstEntry,</span>
<span class="nc" id="L773">					lastEntry);</span>
<span class="nc" id="L774">			return FutureUtils.exception(new BKIncorrectParameterException());</span>
		}

<span class="nc" id="L777">		return readEntriesInternalAsync(firstEntry, lastEntry, false);</span>
	}

	void asyncReadEntriesInternal(long firstEntry, long lastEntry, ReadCallback cb, Object ctx,
			boolean isRecoveryRead) {
<span class="nc bnc" id="L782" title="All 2 branches missed.">		if (!clientCtx.isClientClosed()) {</span>
<span class="nc" id="L783">			readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)</span>
<span class="nc" id="L784">					.whenCompleteAsync(new FutureEventListener&lt;LedgerEntries&gt;() {</span>
						@Override
						public void onSuccess(LedgerEntries entries) {
<span class="nc" id="L787">							cb.readComplete(Code.OK, LedgerHandle.this,</span>
<span class="nc" id="L788">									IteratorUtils.asEnumeration(Iterators.transform(entries.iterator(), le -&gt; {</span>
<span class="nc" id="L789">										LedgerEntry entry = new LedgerEntry((LedgerEntryImpl) le);</span>
<span class="nc" id="L790">										le.close();</span>
<span class="nc" id="L791">										return entry;</span>
									})), ctx);
<span class="nc" id="L793">						}</span>

						@Override
						public void onFailure(Throwable cause) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">							if (cause instanceof BKException) {</span>
<span class="nc" id="L798">								BKException bke = (BKException) cause;</span>
<span class="nc" id="L799">								cb.readComplete(bke.getCode(), LedgerHandle.this, null, ctx);</span>
<span class="nc" id="L800">							} else {</span>
<span class="nc" id="L801">								cb.readComplete(Code.UnexpectedConditionException, LedgerHandle.this, null, ctx);</span>
							}
<span class="nc" id="L803">						}</span>
<span class="nc" id="L804">					}, clientCtx.getMainWorkerPool().chooseThread(ledgerId));</span>
		} else {
<span class="nc" id="L806">			cb.readComplete(Code.ClientClosedException, LedgerHandle.this, null, ctx);</span>
		}
<span class="nc" id="L808">	}</span>

	/*
	 * Read the last entry in the ledger
	 *
	 * @param cb object implementing read callback interface
	 * 
	 * @param ctx control object
	 */
	public void asyncReadLastEntry(ReadCallback cb, Object ctx) {
<span class="nc" id="L818">		long lastEntryId = getLastAddConfirmed();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">		if (lastEntryId &lt; 0) {</span>
			// Ledger was empty, so there is no last entry to read
<span class="nc" id="L821">			cb.readComplete(BKException.Code.NoSuchEntryException, this, null, ctx);</span>
		} else {
<span class="nc" id="L823">			asyncReadEntriesInternal(lastEntryId, lastEntryId, cb, ctx, false);</span>
		}
<span class="nc" id="L825">	}</span>

	public LedgerEntry readLastEntry() throws InterruptedException, BKException {
<span class="nc" id="L828">		long lastEntryId = getLastAddConfirmed();</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">		if (lastEntryId &lt; 0) {</span>
			// Ledger was empty, so there is no last entry to read
<span class="nc" id="L831">			throw new BKException.BKNoSuchEntryException();</span>
		} else {
<span class="nc" id="L833">			CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L834">			asyncReadEntries(lastEntryId, lastEntryId, new SyncReadCallback(result), null);</span>

<span class="nc" id="L836">			return SyncCallbackUtils.waitForResult(result).nextElement();</span>
		}
	}

	CompletableFuture&lt;LedgerEntries&gt; readEntriesInternalAsync(long firstEntry, long lastEntry, boolean isRecoveryRead) {
<span class="nc" id="L841">		PendingReadOp op = new PendingReadOp(this, clientCtx, firstEntry, lastEntry, isRecoveryRead);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		if (!clientCtx.isClientClosed()) {</span>
			// Waiting on the first one.
			// This is not very helpful if there are multiple ensembles or if bookie goes
			// into unresponsive
			// state later after N requests sent.
			// Unfortunately it seems that alternatives are:
			// - send reads one-by-one (up to the app)
			// - rework LedgerHandle to send requests one-by-one (maybe later, potential
			// perf impact)
			// - block worker pool (not good)
			// Even with this implementation one should be more concerned about OOME when
			// all read responses arrive
			// or about overloading bookies with these requests then about submission of
			// many small requests.
			// Naturally one of the solutions would be to submit smaller batches and in this
			// case
			// current implementation will prevent next batch from starting when bookie is
			// unresponsive thus helpful enough.
<span class="nc" id="L860">			DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(firstEntry);</span>
			try {
<span class="nc bnc" id="L862" title="All 2 branches missed.">				if (!waitForWritable(ws, firstEntry, ws.size() - 1, clientCtx.getConf().waitForWriteSetMs)) {</span>
<span class="nc" id="L863">					op.allowFailFastOnUnwritableChannel();</span>
				}
			} finally {
<span class="nc" id="L866">				ws.recycle();</span>
			}

<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (isHandleWritable()) {</span>
				// Ledger handle in read/write mode: submit to OSE for ordered execution.
<span class="nc" id="L871">				clientCtx.getMainWorkerPool().executeOrdered(ledgerId, op);</span>
			} else {
				// Read-only ledger handle: bypass OSE and execute read directly in client
				// thread.
				// This avoids a context-switch to OSE thread and thus reduces latency.
<span class="nc" id="L876">				op.run();</span>
			}
<span class="nc" id="L878">		} else {</span>
<span class="nc" id="L879">			op.future().completeExceptionally(BKException.create(ClientClosedException));</span>
		}
<span class="nc" id="L881">		return op.future();</span>
	}

	/**
	 * Add entry synchronously to an open ledger.
	 *
	 * @param data array of bytes to be written to the ledger do not reuse the
	 *             buffer, bk-client will release it appropriately
	 * @return the entryId of the new inserted entry
	 */
	public long addEntry(byte[] data) throws InterruptedException, BKException {
<span class="nc" id="L892">		return addEntry(data, 0, data.length);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;Long&gt; appendAsync(ByteBuf data) {
<span class="nc" id="L900">		SyncAddCallback callback = new SyncAddCallback();</span>
<span class="nc" id="L901">		asyncAddEntry(data, callback, null);</span>
<span class="nc" id="L902">		return callback;</span>
	}

	/**
	 * Add entry synchronously to an open ledger. This can be used only with
	 * {@link LedgerHandleAdv} returned through ledgers created with
	 * {@link BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
	 *
	 *
	 * @param entryId entryId to be added
	 * @param data    array of bytes to be written to the ledger do not reuse the
	 *                buffer, bk-client will release it appropriately
	 * @return the entryId of the new inserted entry
	 */
	public long addEntry(final long entryId, byte[] data) throws InterruptedException, BKException {
<span class="nc" id="L917">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv interface.&quot;);</span>
<span class="nc" id="L918">		throw BKException.create(BKException.Code.IllegalOpException);</span>
	}

	/**
	 * Add entry synchronously to an open ledger.
	 *
	 * @param data   array of bytes to be written to the ledger do not reuse the
	 *               buffer, bk-client will release it appropriately
	 * @param offset offset from which to take bytes from data
	 * @param length number of bytes to take from data
	 * @return the entryId of the new inserted entry
	 */
	public long addEntry(byte[] data, int offset, int length) throws InterruptedException, BKException {
<span class="nc bnc" id="L931" title="All 2 branches missed.">		if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L932">			LOG.debug(&quot;Adding entry {}&quot;, data);</span>
		}

<span class="nc" id="L935">		SyncAddCallback callback = new SyncAddCallback();</span>
<span class="nc" id="L936">		asyncAddEntry(data, offset, length, callback, null);</span>

<span class="nc" id="L938">		return SyncCallbackUtils.waitForResult(callback);</span>
	}

	/**
	 * Add entry synchronously to an open ledger. This can be used only with
	 * {@link LedgerHandleAdv} returned through ledgers created with
	 * {@link BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
	 *
	 * @param entryId entryId to be added.
	 * @param data    array of bytes to be written to the ledger do not reuse the
	 *                buffer, bk-client will release it appropriately
	 * @param offset  offset from which to take bytes from data
	 * @param length  number of bytes to take from data
	 * @return entryId
	 */
	public long addEntry(final long entryId, byte[] data, int offset, int length)
			throws InterruptedException, BKException {
<span class="nc" id="L955">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L956">		throw BKException.create(BKException.Code.IllegalOpException);</span>
	}

	/**
	 * Add entry asynchronously to an open ledger.
	 *
	 * @param data array of bytes to be written do not reuse the buffer, bk-client
	 *             will release it appropriately
	 * @param cb   object implementing callbackinterface
	 * @param ctx  some control object
	 */
	public void asyncAddEntry(final byte[] data, final AddCallback cb, final Object ctx) {
<span class="nc" id="L968">		asyncAddEntry(data, 0, data.length, cb, ctx);</span>
<span class="nc" id="L969">	}</span>

	/**
	 * Add entry asynchronously to an open ledger. This can be used only with
	 * {@link LedgerHandleAdv} returned through ledgers created with
	 * {@link BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
	 *
	 * @param entryId entryId to be added
	 * @param data    array of bytes to be written do not reuse the buffer,
	 *                bk-client will release it appropriately
	 * @param cb      object implementing callbackinterface
	 * @param ctx     some control object
	 */
	public void asyncAddEntry(final long entryId, final byte[] data, final AddCallback cb, final Object ctx) {
<span class="nc" id="L983">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L984">		cb.addCompleteWithLatency(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, 0, ctx);</span>
<span class="nc" id="L985">	}</span>

	/**
	 * Add entry asynchronously to an open ledger, using an offset and range.
	 *
	 * @param data   array of bytes to be written do not reuse the buffer, bk-client
	 *               will release it appropriately
	 * @param offset offset from which to take bytes from data
	 * @param length number of bytes to take from data
	 * @param cb     object implementing callbackinterface
	 * @param ctx    some control object
	 * @throws ArrayIndexOutOfBoundsException if offset or length is negative or
	 *                                        offset and length sum to a value
	 *                                        higher than the length of data.
	 */
	public void asyncAddEntry(final byte[] data, final int offset, final int length, final AddCallback cb,
			final Object ctx) {
<span class="nc bnc" id="L1002" title="All 6 branches missed.">		if (offset &lt; 0 || length &lt; 0 || (offset + length) &gt; data.length) {</span>
<span class="nc" id="L1003">			throw new ArrayIndexOutOfBoundsException(</span>
					&quot;Invalid values for offset(&quot; + offset + &quot;) or length(&quot; + length + &quot;)&quot;);
		}

<span class="nc" id="L1007">		asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx);</span>
<span class="nc" id="L1008">	}</span>

	public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {
<span class="nc" id="L1011">		PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(), data, writeFlags, cb, ctx);</span>
<span class="nc" id="L1012">		doAsyncAddEntry(op);</span>
<span class="nc" id="L1013">	}</span>

	/**
	 * Add entry asynchronously to an open ledger, using an offset and range. This
	 * can be used only with {@link LedgerHandleAdv} returned through ledgers
	 * created with
	 * {@link BookKeeper#createLedgerAdv(int, int, int, org.apache.bookkeeper.client.BookKeeper.DigestType, byte[])}.
	 *
	 * @param entryId entryId of the entry to add.
	 * @param data    array of bytes to be written do not reuse the buffer,
	 *                bk-client will release it appropriately
	 * @param offset  offset from which to take bytes from data
	 * @param length  number of bytes to take from data
	 * @param cb      object implementing callbackinterface
	 * @param ctx     some control object
	 * @throws ArrayIndexOutOfBoundsException if offset or length is negative or
	 *                                        offset and length sum to a value
	 *                                        higher than the length of data.
	 */
	public void asyncAddEntry(final long entryId, final byte[] data, final int offset, final int length,
			final AddCallback cb, final Object ctx) {
<span class="nc" id="L1034">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L1035">		cb.addCompleteWithLatency(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, 0, ctx);</span>
<span class="nc" id="L1036">	}</span>

	/**
	 * Add entry asynchronously to an open ledger, using an offset and range.
	 *
	 * @param entryId entryId of the entry to add
	 * @param data    array of bytes to be written do not reuse the buffer,
	 *                bk-client will release it appropriately
	 * @param offset  offset from which to take bytes from data
	 * @param length  number of bytes to take from data
	 * @param cb      object implementing callbackinterface
	 * @param ctx     some control object
	 * @throws ArrayIndexOutOfBoundsException if offset or length is negative or
	 *                                        offset and length sum to a value
	 *                                        higher than the length of data.
	 */
	public void asyncAddEntry(final long entryId, final byte[] data, final int offset, final int length,
			final AddCallbackWithLatency cb, final Object ctx) {
<span class="nc" id="L1054">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L1055">		cb.addCompleteWithLatency(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, 0, ctx);</span>
<span class="nc" id="L1056">	}</span>

	/**
	 * Add entry asynchronously to an open ledger, using an offset and range. This
	 * can be used only with {@link LedgerHandleAdv} returned through ledgers
	 * created with {@link createLedgerAdv(int, int, int, DigestType, byte[])}.
	 *
	 * @param entryId entryId of the entry to add.
	 * @param data    io.netty.buffer.ByteBuf of bytes to be written do not reuse
	 *                the buffer, bk-client will release it appropriately
	 * @param cb      object implementing callbackinterface
	 * @param ctx     some control object
	 */
	public void asyncAddEntry(final long entryId, ByteBuf data, final AddCallbackWithLatency cb, final Object ctx) {
<span class="nc" id="L1070">		LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L1071">		cb.addCompleteWithLatency(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, 0, ctx);</span>
<span class="nc" id="L1072">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;Void&gt; force() {
<span class="nc" id="L1079">		CompletableFuture&lt;Void&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L1080">		ForceLedgerOp op = new ForceLedgerOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), result);</span>
<span class="nc" id="L1081">		boolean wasClosed = false;</span>
<span class="nc" id="L1082">		synchronized (this) {</span>
			// synchronized on this to ensure that
			// the ledger isn't closed between checking and
			// updating lastAddPushed
<span class="nc bnc" id="L1086" title="All 2 branches missed.">			if (!isHandleWritable()) {</span>
<span class="nc" id="L1087">				wasClosed = true;</span>
			}
<span class="nc" id="L1089">		}</span>

<span class="nc bnc" id="L1091" title="All 2 branches missed.">		if (wasClosed) {</span>
			// make sure the callback is triggered in main worker pool
			try {
<span class="nc" id="L1094">				clientCtx.getMainWorkerPool().executeOrdered(ledgerId, new SafeRunnable() {</span>
					@Override
					public void safeRun() {
<span class="nc" id="L1097">						LOG.warn(&quot;Force() attempted on a closed ledger: {}&quot;, ledgerId);</span>
<span class="nc" id="L1098">						result.completeExceptionally(new BKException.BKLedgerClosedException());</span>
<span class="nc" id="L1099">					}</span>

					@Override
					public String toString() {
<span class="nc" id="L1103">						return String.format(&quot;force(lid=%d)&quot;, ledgerId);</span>
					}
				});
<span class="nc" id="L1106">			} catch (RejectedExecutionException e) {</span>
<span class="nc" id="L1107">				result.completeExceptionally(new BKException.BKInterruptedException());</span>
<span class="nc" id="L1108">			}</span>
<span class="nc" id="L1109">			return result;</span>
		}

		// early exit: no write has been issued yet
<span class="nc bnc" id="L1113" title="All 2 branches missed.">		if (pendingAddsSequenceHead == INVALID_ENTRY_ID) {</span>
<span class="nc" id="L1114">			clientCtx.getMainWorkerPool().executeOrdered(ledgerId, new SafeRunnable() {</span>
				@Override
				public void safeRun() {
<span class="nc" id="L1117">					FutureUtils.complete(result, null);</span>
<span class="nc" id="L1118">				}</span>

				@Override
				public String toString() {
<span class="nc" id="L1122">					return String.format(&quot;force(lid=%d)&quot;, ledgerId);</span>
				}
			});
<span class="nc" id="L1125">			return result;</span>
		}

		try {
<span class="nc" id="L1129">			clientCtx.getMainWorkerPool().executeOrdered(ledgerId, op);</span>
<span class="nc" id="L1130">		} catch (RejectedExecutionException e) {</span>
<span class="nc" id="L1131">			result.completeExceptionally(new BKException.BKInterruptedException());</span>
<span class="nc" id="L1132">		}</span>
<span class="nc" id="L1133">		return result;</span>
	}

	/**
	 * Make a recovery add entry request. Recovery adds can add to a ledger even if
	 * it has been fenced.
	 *
	 * &lt;p&gt;
	 * This is only valid for bookie and ledger recovery, which may need to
	 * replicate entries to a quorum of bookies to ensure data safety.
	 *
	 * &lt;p&gt;
	 * Normal client should never call this method.
	 */
	void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length, final AddCallback cb,
			final Object ctx) {
<span class="nc" id="L1149">		PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(),</span>
<span class="nc" id="L1150">				Unpooled.wrappedBuffer(data, offset, length), writeFlags, cb, ctx).enableRecoveryAdd();</span>
<span class="nc" id="L1151">		doAsyncAddEntry(op);</span>
<span class="nc" id="L1152">	}</span>

	private boolean isWritesetWritable(DistributionSchedule.WriteSet writeSet, long key, int allowedNonWritableCount) {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">		if (allowedNonWritableCount &lt; 0) {</span>
<span class="nc" id="L1156">			allowedNonWritableCount = 0;</span>
		}

<span class="nc" id="L1159">		final int sz = writeSet.size();</span>
<span class="nc" id="L1160">		final int requiredWritable = sz - allowedNonWritableCount;</span>

<span class="nc" id="L1162">		int nonWritableCount = 0;</span>
<span class="nc" id="L1163">		List&lt;BookieSocketAddress&gt; currentEnsemble = getCurrentEnsemble();</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">		for (int i = 0; i &lt; sz; i++) {</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">			if (!clientCtx.getBookieClient().isWritable(currentEnsemble.get(i), key)) {</span>
<span class="nc" id="L1166">				nonWritableCount++;</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">				if (nonWritableCount &gt;= allowedNonWritableCount) {</span>
<span class="nc" id="L1168">					return false;</span>
				}
			} else {
<span class="nc" id="L1171">				final int knownWritable = i - nonWritableCount;</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">				if (knownWritable &gt;= requiredWritable) {</span>
<span class="nc" id="L1173">					return true;</span>
				}
			}
		}
<span class="nc" id="L1177">		return true;</span>
	}

	protected boolean waitForWritable(DistributionSchedule.WriteSet writeSet, long key, int allowedNonWritableCount,
			long durationMs) {
<span class="nc bnc" id="L1182" title="All 2 branches missed.">		if (durationMs &lt; 0) {</span>
<span class="nc" id="L1183">			return true;</span>
		}

<span class="nc" id="L1186">		final long startTime = MathUtils.nowInNano();</span>
<span class="nc" id="L1187">		boolean success = isWritesetWritable(writeSet, key, allowedNonWritableCount);</span>

<span class="nc bnc" id="L1189" title="All 4 branches missed.">		if (!success &amp;&amp; durationMs &gt; 0) {</span>
<span class="nc" id="L1190">			int backoff = 1;</span>
<span class="nc" id="L1191">			final int maxBackoff = 4;</span>
<span class="nc" id="L1192">			final long deadline = startTime + TimeUnit.MILLISECONDS.toNanos(durationMs);</span>

<span class="nc bnc" id="L1194" title="All 2 branches missed.">			while (!isWritesetWritable(writeSet, key, allowedNonWritableCount)) {</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">				if (MathUtils.nowInNano() &lt; deadline) {</span>
<span class="nc" id="L1196">					long maxSleep = MathUtils.elapsedMSec(startTime);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">					if (maxSleep &lt; 0) {</span>
<span class="nc" id="L1198">						maxSleep = 1;</span>
					}
<span class="nc" id="L1200">					long sleepMs = Math.min(backoff, maxSleep);</span>

					try {
<span class="nc" id="L1203">						TimeUnit.MILLISECONDS.sleep(sleepMs);</span>
<span class="nc" id="L1204">					} catch (InterruptedException e) {</span>
<span class="nc" id="L1205">						Thread.currentThread().interrupt();</span>
<span class="nc" id="L1206">						success = isWritesetWritable(writeSet, key, allowedNonWritableCount);</span>
<span class="nc" id="L1207">						break;</span>
<span class="nc" id="L1208">					}</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">					if (backoff &lt;= maxBackoff) {</span>
<span class="nc" id="L1210">						backoff++;</span>
					}
<span class="nc" id="L1212">				} else {</span>
<span class="nc" id="L1213">					success = false;</span>
<span class="nc" id="L1214">					break;</span>
				}
			}
<span class="nc bnc" id="L1217" title="All 2 branches missed.">			if (backoff &gt; 1) {</span>
<span class="nc" id="L1218">				LOG.info(&quot;Spent {} ms waiting for {} writable channels&quot;, MathUtils.elapsedMSec(startTime),</span>
<span class="nc" id="L1219">						writeSet.size() - allowedNonWritableCount);</span>
			}
		}

<span class="nc bnc" id="L1223" title="All 2 branches missed.">		if (success) {</span>
<span class="nc" id="L1224">			clientChannelWriteWaitStats.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime),</span>
					TimeUnit.NANOSECONDS);
		} else {
<span class="nc" id="L1227">			clientChannelWriteWaitStats.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
		}
<span class="nc" id="L1229">		return success;</span>
	}

	protected void doAsyncAddEntry(final PendingAddOp op) {
<span class="nc bnc" id="L1233" title="All 2 branches missed.">		if (throttler != null) {</span>
<span class="nc" id="L1234">			throttler.acquire();</span>
		}

<span class="nc" id="L1237">		boolean wasClosed = false;</span>
<span class="nc" id="L1238">		synchronized (this) {</span>
			// synchronized on this to ensure that
			// the ledger isn't closed between checking and
			// updating lastAddPushed
<span class="nc bnc" id="L1242" title="All 2 branches missed.">			if (isHandleWritable()) {</span>
<span class="nc" id="L1243">				long entryId = ++lastAddPushed;</span>
<span class="nc" id="L1244">				long currentLedgerLength = addToLength(op.payload.readableBytes());</span>
<span class="nc" id="L1245">				op.setEntryId(entryId);</span>
<span class="nc" id="L1246">				op.setLedgerLength(currentLedgerLength);</span>
<span class="nc" id="L1247">				pendingAddOps.add(op);</span>
<span class="nc" id="L1248">			} else {</span>
<span class="nc" id="L1249">				wasClosed = true;</span>
			}
<span class="nc" id="L1251">		}</span>

<span class="nc bnc" id="L1253" title="All 2 branches missed.">		if (wasClosed) {</span>
			// make sure the callback is triggered in main worker pool
			try {
<span class="nc" id="L1256">				clientCtx.getMainWorkerPool().executeOrdered(ledgerId, new SafeRunnable() {</span>
					@Override
					public void safeRun() {
<span class="nc" id="L1259">						LOG.warn(&quot;Attempt to add to closed ledger: {}&quot;, ledgerId);</span>
<span class="nc" id="L1260">						op.cb.addCompleteWithLatency(BKException.Code.LedgerClosedException, LedgerHandle.this,</span>
								INVALID_ENTRY_ID, 0, op.ctx);
<span class="nc" id="L1262">					}</span>

					@Override
					public String toString() {
<span class="nc" id="L1266">						return String.format(&quot;AsyncAddEntryToClosedLedger(lid=%d)&quot;, ledgerId);</span>
					}
				});
<span class="nc" id="L1269">			} catch (RejectedExecutionException e) {</span>
<span class="nc" id="L1270">				op.cb.addCompleteWithLatency(</span>
<span class="nc" id="L1271">						BookKeeper.getReturnRc(clientCtx.getBookieClient(), BKException.Code.InterruptedException),</span>
						LedgerHandle.this, INVALID_ENTRY_ID, 0, op.ctx);
<span class="nc" id="L1273">			}</span>
<span class="nc" id="L1274">			return;</span>
		}

<span class="nc" id="L1277">		DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());</span>
		try {
<span class="nc bnc" id="L1279" title="All 2 branches missed.">			if (!waitForWritable(ws, op.getEntryId(), 0, clientCtx.getConf().waitForWriteSetMs)) {</span>
<span class="nc" id="L1280">				op.allowFailFastOnUnwritableChannel();</span>
			}
		} finally {
<span class="nc" id="L1283">			ws.recycle();</span>
		}

		try {
<span class="nc" id="L1287">			clientCtx.getMainWorkerPool().executeOrdered(ledgerId, op);</span>
<span class="nc" id="L1288">		} catch (RejectedExecutionException e) {</span>
<span class="nc" id="L1289">			op.cb.addCompleteWithLatency(</span>
<span class="nc" id="L1290">					BookKeeper.getReturnRc(clientCtx.getBookieClient(), BKException.Code.InterruptedException),</span>
					LedgerHandle.this, INVALID_ENTRY_ID, 0, op.ctx);
<span class="nc" id="L1292">		}</span>
<span class="nc" id="L1293">	}</span>

	synchronized void updateLastConfirmed(long lac, long len) {
<span class="nc bnc" id="L1296" title="All 2 branches missed.">		if (lac &gt; lastAddConfirmed) {</span>
<span class="nc" id="L1297">			lastAddConfirmed = lac;</span>
<span class="nc" id="L1298">			lacUpdateHitsCounter.inc();</span>
		} else {
<span class="nc" id="L1300">			lacUpdateMissesCounter.inc();</span>
		}
<span class="nc" id="L1302">		lastAddPushed = Math.max(lastAddPushed, lac);</span>
<span class="nc" id="L1303">		length = Math.max(length, len);</span>
<span class="nc" id="L1304">	}</span>

	/**
	 * Obtains asynchronously the last confirmed write from a quorum of bookies.
	 * This call obtains the the last add confirmed each bookie has received for
	 * this ledger and returns the maximum. If the ledger has been closed, the value
	 * returned by this call may not correspond to the id of the last entry of the
	 * ledger, since it reads the hint of bookies. Consequently, in the case the
	 * ledger has been closed, it may return a different value than
	 * getLastAddConfirmed, which returns the local value of the ledger handle.
	 *
	 * @see #getLastAddConfirmed()
	 *
	 * @param cb
	 * @param ctx
	 */

	public void asyncReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
		boolean isClosed;
		long lastEntryId;
<span class="nc" id="L1324">		synchronized (this) {</span>
<span class="nc" id="L1325">			LedgerMetadata metadata = getLedgerMetadata();</span>
<span class="nc" id="L1326">			isClosed = metadata.isClosed();</span>
<span class="nc" id="L1327">			lastEntryId = metadata.getLastEntryId();</span>
<span class="nc" id="L1328">		}</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">		if (isClosed) {</span>
<span class="nc" id="L1330">			cb.readLastConfirmedComplete(BKException.Code.OK, lastEntryId, ctx);</span>
<span class="nc" id="L1331">			return;</span>
		}

<span class="nc" id="L1334">		ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {</span>
			@Override
			public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {
<span class="nc bnc" id="L1337" title="All 2 branches missed.">				if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L1338">					updateLastConfirmed(data.getLastAddConfirmed(), data.getLength());</span>
<span class="nc" id="L1339">					cb.readLastConfirmedComplete(rc, data.getLastAddConfirmed(), ctx);</span>
				} else {
<span class="nc" id="L1341">					cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
				}
<span class="nc" id="L1343">			}</span>
		};

<span class="nc" id="L1346">		new ReadLastConfirmedOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb).initiate();</span>
<span class="nc" id="L1347">	}</span>

	/**
	 * Obtains asynchronously the last confirmed write from a quorum of bookies. It
	 * is similar as
	 * {@link #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, Object)},
	 * but it doesn't wait all the responses from the quorum. It would callback
	 * immediately if it received a LAC which is larger than current LAC.
	 *
	 * @see #asyncTryReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback,
	 *      Object)
	 *
	 * @param cb  callback to return read last confirmed
	 * @param ctx callback context
	 */
	public void asyncTryReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
		boolean isClosed;
		long lastEntryId;
<span class="nc" id="L1365">		synchronized (this) {</span>
<span class="nc" id="L1366">			LedgerMetadata metadata = getLedgerMetadata();</span>
<span class="nc" id="L1367">			isClosed = metadata.isClosed();</span>
<span class="nc" id="L1368">			lastEntryId = metadata.getLastEntryId();</span>
<span class="nc" id="L1369">		}</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">		if (isClosed) {</span>
<span class="nc" id="L1371">			cb.readLastConfirmedComplete(BKException.Code.OK, lastEntryId, ctx);</span>
<span class="nc" id="L1372">			return;</span>
		}
<span class="nc" id="L1374">		ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {</span>
<span class="nc" id="L1375">			AtomicBoolean completed = new AtomicBoolean(false);</span>

			@Override
			public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {
<span class="nc bnc" id="L1379" title="All 2 branches missed.">				if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L1380">					updateLastConfirmed(data.getLastAddConfirmed(), data.getLength());</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">					if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1382">						cb.readLastConfirmedComplete(rc, data.getLastAddConfirmed(), ctx);</span>
					}
				} else {
<span class="nc bnc" id="L1385" title="All 2 branches missed.">					if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1386">						cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
					}
				}
<span class="nc" id="L1389">			}</span>
		};
<span class="nc" id="L1391">		new TryReadLastConfirmedOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb,</span>
<span class="nc" id="L1392">				getLastAddConfirmed()).initiate();</span>
<span class="nc" id="L1393">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;Long&gt; tryReadLastAddConfirmedAsync() {
<span class="nc" id="L1400">		FutureReadLastConfirmed result = new FutureReadLastConfirmed();</span>
<span class="nc" id="L1401">		asyncTryReadLastConfirmed(result, null);</span>
<span class="nc" id="L1402">		return result;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;Long&gt; readLastAddConfirmedAsync() {
<span class="nc" id="L1410">		FutureReadLastConfirmed result = new FutureReadLastConfirmed();</span>
<span class="nc" id="L1411">		asyncReadLastConfirmed(result, null);</span>
<span class="nc" id="L1412">		return result;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public CompletableFuture&lt;LastConfirmedAndEntry&gt; readLastAddConfirmedAndEntryAsync(long entryId,
			long timeOutInMillis, boolean parallel) {
<span class="nc" id="L1421">		FutureReadLastConfirmedAndEntry result = new FutureReadLastConfirmedAndEntry();</span>
<span class="nc" id="L1422">		asyncReadLastConfirmedAndEntry(entryId, timeOutInMillis, parallel, result, null);</span>
<span class="nc" id="L1423">		return result;</span>
	}

	/**
	 * Asynchronous read next entry and the latest last add confirmed. If the next
	 * entryId is less than known last add confirmed, the call will read next entry
	 * directly. If the next entryId is ahead of known last add confirmed, the call
	 * will issue a long poll read to wait for the next entry &lt;i&gt;entryId&lt;/i&gt;.
	 *
	 * &lt;p&gt;
	 * The callback will return the latest last add confirmed and next entry if it
	 * is available within timeout period &lt;i&gt;timeOutInMillis&lt;/i&gt;.
	 *
	 * @param entryId         next entry id to read
	 * @param timeOutInMillis timeout period to wait for the entry id to be
	 *                        available (for long poll only)
	 * @param parallel        whether to issue the long poll reads in parallel
	 * @param cb              callback to return the result
	 * @param ctx             callback context
	 */
	public void asyncReadLastConfirmedAndEntry(final long entryId, final long timeOutInMillis, final boolean parallel,
			final AsyncCallback.ReadLastConfirmedAndEntryCallback cb, final Object ctx) {
		boolean isClosed;
		long lac;
<span class="nc" id="L1447">		synchronized (this) {</span>
<span class="nc" id="L1448">			LedgerMetadata metadata = getLedgerMetadata();</span>
<span class="nc" id="L1449">			isClosed = metadata.isClosed();</span>
<span class="nc" id="L1450">			lac = metadata.getLastEntryId();</span>
<span class="nc" id="L1451">		}</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">		if (isClosed) {</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">			if (entryId &gt; lac) {</span>
<span class="nc" id="L1454">				cb.readLastConfirmedAndEntryComplete(BKException.Code.OK, lac, null, ctx);</span>
<span class="nc" id="L1455">				return;</span>
			}
		} else {
<span class="nc" id="L1458">			lac = getLastAddConfirmed();</span>
		}
<span class="nc bnc" id="L1460" title="All 2 branches missed.">		if (entryId &lt;= lac) {</span>
<span class="nc" id="L1461">			asyncReadEntries(entryId, entryId, new ReadCallback() {</span>
				@Override
				public void readComplete(int rc, LedgerHandle lh, Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="nc bnc" id="L1464" title="All 2 branches missed.">					if (BKException.Code.OK == rc) {</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">						if (seq.hasMoreElements()) {</span>
<span class="nc" id="L1466">							cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), seq.nextElement(), ctx);</span>
						} else {
<span class="nc" id="L1468">							cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), null, ctx);</span>
						}
					} else {
<span class="nc" id="L1471">						cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);</span>
					}
<span class="nc" id="L1473">				}</span>
			}, ctx);
<span class="nc" id="L1475">			return;</span>
		}
		// wait for entry &lt;i&gt;entryId&lt;/i&gt;
<span class="nc" id="L1478">		ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback innercb = new ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback() {</span>
<span class="nc" id="L1479">			AtomicBoolean completed = new AtomicBoolean(false);</span>

			@Override
			public void readLastConfirmedAndEntryComplete(int rc, long lastAddConfirmed, LedgerEntry entry) {
<span class="nc bnc" id="L1483" title="All 2 branches missed.">				if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">					if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1485">						cb.readLastConfirmedAndEntryComplete(rc, lastAddConfirmed, entry, ctx);</span>
					}
				} else {
<span class="nc bnc" id="L1488" title="All 2 branches missed.">					if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1489">						cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);</span>
					}
				}
<span class="nc" id="L1492">			}</span>
		};
<span class="nc" id="L1494">		new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)</span>
<span class="nc" id="L1495">				.parallelRead(parallel).initiate();</span>
<span class="nc" id="L1496">	}</span>

	/**
	 * Context objects for synchronous call to read last confirmed.
	 */
	static class LastConfirmedCtx {
		static final long ENTRY_ID_PENDING = -10;
		long response;
		int rc;

<span class="nc" id="L1506">		LastConfirmedCtx() {</span>
<span class="nc" id="L1507">			this.response = ENTRY_ID_PENDING;</span>
<span class="nc" id="L1508">		}</span>

		void setLastConfirmed(long lastConfirmed) {
<span class="nc" id="L1511">			this.response = lastConfirmed;</span>
<span class="nc" id="L1512">		}</span>

		long getlastConfirmed() {
<span class="nc" id="L1515">			return this.response;</span>
		}

		void setRC(int rc) {
<span class="nc" id="L1519">			this.rc = rc;</span>
<span class="nc" id="L1520">		}</span>

		int getRC() {
<span class="nc" id="L1523">			return this.rc;</span>
		}

		boolean ready() {
<span class="nc bnc" id="L1527" title="All 2 branches missed.">			return (this.response != ENTRY_ID_PENDING);</span>
		}
	}

	/**
	 * Obtains synchronously the last confirmed write from a quorum of bookies. This
	 * call obtains the the last add confirmed each bookie has received for this
	 * ledger and returns the maximum. If the ledger has been closed, the value
	 * returned by this call may not correspond to the id of the last entry of the
	 * ledger, since it reads the hint of bookies. Consequently, in the case the
	 * ledger has been closed, it may return a different value than
	 * getLastAddConfirmed, which returns the local value of the ledger handle.
	 *
	 * @see #getLastAddConfirmed()
	 *
	 * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID
	 *         INVALID_ENTRY_ID} if no entry has been confirmed
	 * @throws InterruptedException
	 * @throws BKException
	 */
	public long readLastConfirmed() throws InterruptedException, BKException {
<span class="nc" id="L1548">		LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1549">		asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1550">		synchronized (ctx) {</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">			while (!ctx.ready()) {</span>
<span class="nc" id="L1552">				ctx.wait();</span>
			}
<span class="nc" id="L1554">		}</span>

<span class="nc bnc" id="L1556" title="All 2 branches missed.">		if (ctx.getRC() != BKException.Code.OK) {</span>
<span class="nc" id="L1557">			throw BKException.create(ctx.getRC());</span>
		}
<span class="nc" id="L1559">		return ctx.getlastConfirmed();</span>
	}

	/**
	 * Obtains synchronously the last confirmed write from a quorum of bookies. It
	 * is similar as {@link #readLastConfirmed()}, but it doesn't wait all the
	 * responses from the quorum. It would callback immediately if it received a LAC
	 * which is larger than current LAC.
	 *
	 * @see #readLastConfirmed()
	 *
	 * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID
	 *         INVALID_ENTRY_ID} if no entry has been confirmed
	 * @throws InterruptedException
	 * @throws BKException
	 */
	public long tryReadLastConfirmed() throws InterruptedException, BKException {
<span class="nc" id="L1576">		LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1577">		asyncTryReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1578">		synchronized (ctx) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">			while (!ctx.ready()) {</span>
<span class="nc" id="L1580">				ctx.wait();</span>
			}
<span class="nc" id="L1582">		}</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">		if (ctx.getRC() != BKException.Code.OK) {</span>
<span class="nc" id="L1584">			throw BKException.create(ctx.getRC());</span>
		}
<span class="nc" id="L1586">		return ctx.getlastConfirmed();</span>
	}

	/**
	 * Obtains asynchronously the explicit last add confirmed from a quorum of
	 * bookies. This call obtains Explicit LAC value and piggy-backed LAC value
	 * (just like
	 * {@link #asyncReadLastConfirmed(ReadLastConfirmedCallback, Object)}) from each
	 * bookie in the ensemble and returns the maximum. If in the write LedgerHandle,
	 * explicitLAC feature is not enabled then this call behavior will be similar to
	 * {@link #asyncReadLastConfirmed(ReadLastConfirmedCallback, Object)}. If the
	 * read explicit lastaddconfirmed is greater than getLastAddConfirmed, then it
	 * updates the lastAddConfirmed of this ledgerhandle. If the ledger has been
	 * closed, it returns the value of the last add confirmed from the metadata.
	 *
	 * @see #getLastAddConfirmed()
	 *
	 * @param cb  callback to return read explicit last confirmed
	 * @param ctx callback context
	 */
	public void asyncReadExplicitLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
		boolean isClosed;
<span class="nc" id="L1608">		synchronized (this) {</span>
<span class="nc" id="L1609">			LedgerMetadata metadata = getLedgerMetadata();</span>
<span class="nc" id="L1610">			isClosed = metadata.isClosed();</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">			if (isClosed) {</span>
<span class="nc" id="L1612">				lastAddConfirmed = metadata.getLastEntryId();</span>
<span class="nc" id="L1613">				length = metadata.getLength();</span>
			}
<span class="nc" id="L1615">		}</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">		if (isClosed) {</span>
<span class="nc" id="L1617">			cb.readLastConfirmedComplete(BKException.Code.OK, lastAddConfirmed, ctx);</span>
<span class="nc" id="L1618">			return;</span>
		}

<span class="nc" id="L1621">		PendingReadLacOp.LacCallback innercb = new PendingReadLacOp.LacCallback() {</span>

			@Override
			public void getLacComplete(int rc, long lac) {
<span class="nc bnc" id="L1625" title="All 2 branches missed.">				if (rc == BKException.Code.OK) {</span>
					// here we are trying to update lac only but not length
<span class="nc" id="L1627">					updateLastConfirmed(lac, 0);</span>
<span class="nc" id="L1628">					cb.readLastConfirmedComplete(rc, lac, ctx);</span>
				} else {
<span class="nc" id="L1630">					cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
				}
<span class="nc" id="L1632">			}</span>
		};
<span class="nc" id="L1634">		new PendingReadLacOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb).initiate();</span>
<span class="nc" id="L1635">	}</span>

	/*
	 * Obtains synchronously the explicit last add confirmed from a quorum of
	 * bookies. This call obtains Explicit LAC value and piggy-backed LAC value
	 * (just like {@Link #readLastAddConfirmed()) from each bookie in the ensemble
	 * and returns the maximum. If in the write LedgerHandle, explicitLAC feature is
	 * not enabled then this call behavior will be similar to {@Link
	 * #readLastAddConfirmed()}. If the read explicit lastaddconfirmed is greater
	 * than getLastAddConfirmed, then it updates the lastAddConfirmed of this
	 * ledgerhandle. If the ledger has been closed, it returns the value of the last
	 * add confirmed from the metadata.
	 *
	 * @see #getLastAddConfirmed()
	 *
	 * @return The entry id of the explicit last confirmed write or {@link
	 * #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been confirmed.
	 * 
	 * @throws InterruptedException
	 * 
	 * @throws BKException
	 */
	public long readExplicitLastConfirmed() throws InterruptedException, BKException {
<span class="nc" id="L1658">		LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1659">		asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1660">		synchronized (ctx) {</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">			while (!ctx.ready()) {</span>
<span class="nc" id="L1662">				ctx.wait();</span>
			}
<span class="nc" id="L1664">		}</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">		if (ctx.getRC() != BKException.Code.OK) {</span>
<span class="nc" id="L1666">			throw BKException.create(ctx.getRC());</span>
		}
<span class="nc" id="L1668">		return ctx.getlastConfirmed();</span>
	}

	// close the ledger and send fails to all the adds in the pipeline
	void handleUnrecoverableErrorDuringAdd(int rc) {
<span class="nc bnc" id="L1673" title="All 2 branches missed.">		if (getLedgerMetadata().getState() == LedgerMetadata.State.IN_RECOVERY) {</span>
			// we should not close ledger if ledger is recovery mode
			// otherwise we may lose entry.
<span class="nc" id="L1676">			errorOutPendingAdds(rc);</span>
<span class="nc" id="L1677">			return;</span>
		}
<span class="nc" id="L1679">		LOG.error(&quot;Closing ledger {} due to {}&quot;, ledgerId, BKException.codeLogger(rc));</span>
<span class="nc" id="L1680">		asyncCloseInternal(NoopCloseCallback.instance, null, rc);</span>
<span class="nc" id="L1681">	}</span>

	private void monitorPendingAddOps() {
<span class="nc" id="L1684">		int timedOut = 0;</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">		for (PendingAddOp op : pendingAddOps) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">			if (op.maybeTimeout()) {</span>
<span class="nc" id="L1687">				timedOut++;</span>
			}
<span class="nc" id="L1689">		}</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">		if (timedOut &gt; 0) {</span>
<span class="nc" id="L1691">			LOG.info(&quot;Timed out {} add ops&quot;, timedOut);</span>
		}
<span class="nc" id="L1693">	}</span>

	void errorOutPendingAdds(int rc) {
<span class="nc" id="L1696">		errorOutPendingAdds(rc, drainPendingAddsAndAdjustLength());</span>
<span class="nc" id="L1697">	}</span>

	synchronized List&lt;PendingAddOp&gt; drainPendingAddsAndAdjustLength() {
		PendingAddOp pendingAddOp;
<span class="nc" id="L1701">		List&lt;PendingAddOp&gt; opsDrained = new ArrayList&lt;PendingAddOp&gt;(pendingAddOps.size());</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">		while ((pendingAddOp = pendingAddOps.poll()) != null) {</span>
<span class="nc" id="L1703">			addToLength(-pendingAddOp.entryLength);</span>
<span class="nc" id="L1704">			opsDrained.add(pendingAddOp);</span>
		}
<span class="nc" id="L1706">		return opsDrained;</span>
	}

	void errorOutPendingAdds(int rc, List&lt;PendingAddOp&gt; ops) {
<span class="nc bnc" id="L1710" title="All 2 branches missed.">		for (PendingAddOp op : ops) {</span>
<span class="nc" id="L1711">			op.submitCallback(rc);</span>
<span class="nc" id="L1712">		}</span>
<span class="nc" id="L1713">	}</span>

	void sendAddSuccessCallbacks() {
		// Start from the head of the queue and proceed while there are
		// entries that have had all their responses come back
		PendingAddOp pendingAddOp;

<span class="nc bnc" id="L1720" title="All 4 branches missed.">		while ((pendingAddOp = pendingAddOps.peek()) != null &amp;&amp; !changingEnsemble) {</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">			if (!pendingAddOp.completed) {</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">				if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1723">					LOG.debug(&quot;pending add not completed: {}&quot;, pendingAddOp);</span>
				}
<span class="nc" id="L1725">				return;</span>
			}
			// Check if it is the next entry in the sequence.
<span class="nc bnc" id="L1728" title="All 4 branches missed.">			if (pendingAddOp.entryId != 0 &amp;&amp; pendingAddOp.entryId != pendingAddsSequenceHead + 1) {</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">				if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1730">					LOG.debug(&quot;Head of the queue entryId: {} is not the expected value: {}&quot;, pendingAddOp.entryId,</span>
<span class="nc" id="L1731">							pendingAddsSequenceHead + 1);</span>
				}
<span class="nc" id="L1733">				return;</span>
			}

<span class="nc" id="L1736">			pendingAddOps.remove();</span>
<span class="nc" id="L1737">			explicitLacFlushPolicy.updatePiggyBackedLac(lastAddConfirmed);</span>
<span class="nc" id="L1738">			pendingAddsSequenceHead = pendingAddOp.entryId;</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">			if (!writeFlags.contains(WriteFlag.DEFERRED_SYNC)) {</span>
<span class="nc" id="L1740">				this.lastAddConfirmed = pendingAddsSequenceHead;</span>
			}

<span class="nc" id="L1743">			pendingAddOp.submitCallback(BKException.Code.OK);</span>
		}

<span class="nc" id="L1746">	}</span>

	@VisibleForTesting
	boolean hasDelayedWriteFailedBookies() {
<span class="nc bnc" id="L1750" title="All 2 branches missed.">		return !delayedWriteFailedBookies.isEmpty();</span>
	}

	void notifyWriteFailed(int index, BookieSocketAddress addr) {
<span class="nc" id="L1754">		synchronized (metadataLock) {</span>
<span class="nc" id="L1755">			delayedWriteFailedBookies.put(index, addr);</span>
<span class="nc" id="L1756">		}</span>
<span class="nc" id="L1757">	}</span>

	void maybeHandleDelayedWriteBookieFailure() {
<span class="nc" id="L1760">		synchronized (metadataLock) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">			if (delayedWriteFailedBookies.isEmpty()) {</span>
<span class="nc" id="L1762">				return;</span>
			}
<span class="nc" id="L1764">			Map&lt;Integer, BookieSocketAddress&gt; toReplace = new HashMap&lt;&gt;(delayedWriteFailedBookies);</span>
<span class="nc" id="L1765">			delayedWriteFailedBookies.clear();</span>

			// Original intent of this change is to do a best-effort ensemble change.
			// But this is not possible until the local metadata is completely immutable.
			// Until the feature &quot;Make LedgerMetadata Immutable #610&quot; Is complete we will
			// use
			// handleBookieFailure() to handle delayed writes as regular bookie failures.
<span class="nc" id="L1772">			handleBookieFailure(toReplace);</span>
<span class="nc" id="L1773">		}</span>
<span class="nc" id="L1774">	}</span>

	void handleBookieFailure(final Map&lt;Integer, BookieSocketAddress&gt; failedBookies) {
<span class="nc bnc" id="L1777" title="All 2 branches missed.">		if (clientCtx.getConf().disableEnsembleChangeFeature.isAvailable()) {</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1779">				LOG.debug(&quot;Ensemble change is disabled. Retry sending to failed bookies {} for ledger {}.&quot;,</span>
<span class="nc" id="L1780">						failedBookies, ledgerId);</span>
			}
<span class="nc" id="L1782">			unsetSuccessAndSendWriteRequest(getCurrentEnsemble(), failedBookies.keySet());</span>
<span class="nc" id="L1783">			return;</span>
		}

<span class="nc bnc" id="L1786" title="All 2 branches missed.">		if (writeFlags.contains(WriteFlag.DEFERRED_SYNC)) {</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1788">				LOG.debug(&quot;Cannot perform ensemble change with write flags {}. &quot; + &quot;Failed bookies {} for ledger {}.&quot;,</span>
<span class="nc" id="L1789">						writeFlags, failedBookies, ledgerId);</span>
			}
<span class="nc" id="L1791">			handleUnrecoverableErrorDuringAdd(WriteException);</span>
<span class="nc" id="L1792">			return;</span>
		}

<span class="nc" id="L1795">		boolean triggerLoop = false;</span>
<span class="nc" id="L1796">		Map&lt;Integer, BookieSocketAddress&gt; toReplace = null;</span>
<span class="nc" id="L1797">		List&lt;BookieSocketAddress&gt; origEnsemble = null;</span>
<span class="nc" id="L1798">		synchronized (metadataLock) {</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">			if (changingEnsemble) {</span>
<span class="nc" id="L1800">				delayedWriteFailedBookies.putAll(failedBookies);</span>
			} else {
<span class="nc" id="L1802">				changingEnsemble = true;</span>
<span class="nc" id="L1803">				triggerLoop = true;</span>

<span class="nc" id="L1805">				toReplace = new HashMap&lt;&gt;(delayedWriteFailedBookies);</span>
<span class="nc" id="L1806">				delayedWriteFailedBookies.clear();</span>
<span class="nc" id="L1807">				toReplace.putAll(failedBookies);</span>

<span class="nc" id="L1809">				origEnsemble = getCurrentEnsemble();</span>
			}
<span class="nc" id="L1811">		}</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">		if (triggerLoop) {</span>
<span class="nc" id="L1813">			ensembleChangeLoop(origEnsemble, toReplace);</span>
		}
<span class="nc" id="L1815">	}</span>

	void ensembleChangeLoop(List&lt;BookieSocketAddress&gt; origEnsemble, Map&lt;Integer, BookieSocketAddress&gt; failedBookies) {
<span class="nc" id="L1818">		int ensembleChangeId = numEnsembleChanges.incrementAndGet();</span>
<span class="nc" id="L1819">		String logContext = String.format(&quot;[EnsembleChange(ledger:%d, change-id:%010d)]&quot;, ledgerId, ensembleChangeId);</span>

		// when the ensemble changes are too frequent, close handle
<span class="nc bnc" id="L1822" title="All 2 branches missed.">		if (ensembleChangeId &gt; clientCtx.getConf().maxAllowedEnsembleChanges) {</span>
<span class="nc" id="L1823">			LOG.info(&quot;{} reaches max allowed ensemble change number {}&quot;, logContext,</span>
<span class="nc" id="L1824">					clientCtx.getConf().maxAllowedEnsembleChanges);</span>
<span class="nc" id="L1825">			handleUnrecoverableErrorDuringAdd(WriteException);</span>
<span class="nc" id="L1826">			return;</span>
		}

<span class="nc bnc" id="L1829" title="All 2 branches missed.">		if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1830">			LOG.debug(&quot;{} Replacing {} in {}&quot;, logContext, failedBookies, origEnsemble);</span>
		}

<span class="nc" id="L1833">		AtomicInteger attempts = new AtomicInteger(0);</span>
<span class="nc" id="L1834">		new MetadataUpdateLoop(clientCtx.getLedgerManager(), getId(), this::getVersionedLedgerMetadata,</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">				(metadata) -&gt; metadata.getState() == LedgerMetadata.State.OPEN</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">						&amp;&amp; failedBookies.entrySet().stream().anyMatch(e -&gt; LedgerMetadataUtils</span>
<span class="nc" id="L1837">								.getLastEnsembleValue(metadata).get(e.getKey()).equals(e.getValue())),</span>
				(metadata) -&gt; {
<span class="nc" id="L1839">					attempts.incrementAndGet();</span>

<span class="nc" id="L1841">					List&lt;BookieSocketAddress&gt; currentEnsemble = getCurrentEnsemble();</span>
<span class="nc" id="L1842">					List&lt;BookieSocketAddress&gt; newEnsemble = EnsembleUtils.replaceBookiesInEnsemble(</span>
<span class="nc" id="L1843">							clientCtx.getBookieWatcher(), metadata, currentEnsemble, failedBookies, logContext);</span>
<span class="nc" id="L1844">					Long lastEnsembleKey = LedgerMetadataUtils.getLastEnsembleKey(metadata);</span>
<span class="nc" id="L1845">					LedgerMetadataBuilder builder = LedgerMetadataBuilder.from(metadata);</span>
<span class="nc" id="L1846">					long newEnsembleStartEntry = getLastAddConfirmed() + 1;</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">					checkState(lastEnsembleKey &lt;= newEnsembleStartEntry,</span>
							&quot;New ensemble must either replace the last ensemble, or add a new one&quot;);
<span class="nc bnc" id="L1849" title="All 2 branches missed.">					if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1850">						LOG.debug(&quot;{}[attempt:{}] changing ensemble from: {} to: {} starting at entry: {}&quot;, logContext,</span>
<span class="nc" id="L1851">								attempts.get(), currentEnsemble, newEnsemble, newEnsembleStartEntry);</span>
					}

<span class="nc bnc" id="L1854" title="All 2 branches missed.">					if (lastEnsembleKey.equals(newEnsembleStartEntry)) {</span>
<span class="nc" id="L1855">						return builder.replaceEnsembleEntry(newEnsembleStartEntry, newEnsemble).build();</span>
					} else {
<span class="nc" id="L1857">						return builder.newEnsembleEntry(newEnsembleStartEntry, newEnsemble).build();</span>
					}
<span class="nc" id="L1859">				}, this::setLedgerMetadata).run().whenCompleteAsync((metadata, ex) -&gt; {</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">					if (ex != null) {</span>
<span class="nc" id="L1861">						LOG.warn(&quot;{}[attempt:{}] Exception changing ensemble&quot;, logContext, attempts.get(), ex);</span>
<span class="nc" id="L1862">						handleUnrecoverableErrorDuringAdd(BKException.getExceptionCode(ex, WriteException));</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">					} else if (metadata.getValue().isClosed()) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">						if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1865">							LOG.debug(</span>
									&quot;{}[attempt:{}] Metadata closed during attempt to replace bookie.&quot;
											+ &quot; Another client must have recovered the ledger.&quot;,
<span class="nc" id="L1868">									logContext, attempts.get());</span>
						}
<span class="nc" id="L1870">						handleUnrecoverableErrorDuringAdd(BKException.Code.LedgerClosedException);</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">					} else if (metadata.getValue().getState() == LedgerMetadata.State.IN_RECOVERY) {</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">						if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1873">							LOG.debug(</span>
									&quot;{}[attempt:{}] Metadata marked as in-recovery during attempt to replace bookie.&quot;
											+ &quot; Another client must be recovering the ledger.&quot;,
<span class="nc" id="L1876">									logContext, attempts.get());</span>
						}

<span class="nc" id="L1879">						handleUnrecoverableErrorDuringAdd(BKException.Code.LedgerFencedException);</span>
					} else {
<span class="nc bnc" id="L1881" title="All 2 branches missed.">						if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1882">							LOG.debug(&quot;{}[attempt:{}] Success updating metadata.&quot;, logContext, attempts.get());</span>
						}

<span class="nc" id="L1885">						List&lt;BookieSocketAddress&gt; newEnsemble = null;</span>
<span class="nc" id="L1886">						Set&lt;Integer&gt; replaced = null;</span>
<span class="nc" id="L1887">						synchronized (metadataLock) {</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">							if (!delayedWriteFailedBookies.isEmpty()) {</span>
<span class="nc" id="L1889">								Map&lt;Integer, BookieSocketAddress&gt; toReplace = new HashMap&lt;&gt;(delayedWriteFailedBookies);</span>
<span class="nc" id="L1890">								delayedWriteFailedBookies.clear();</span>

<span class="nc" id="L1892">								ensembleChangeLoop(origEnsemble, toReplace);</span>
<span class="nc" id="L1893">							} else {</span>
<span class="nc" id="L1894">								newEnsemble = getCurrentEnsemble();</span>
<span class="nc" id="L1895">								replaced = EnsembleUtils.diffEnsemble(origEnsemble, newEnsemble);</span>
<span class="nc" id="L1896">								LOG.info(&quot;New Ensemble: {} for ledger: {}&quot;, newEnsemble, ledgerId);</span>

<span class="nc" id="L1898">								changingEnsemble = false;</span>
							}
<span class="nc" id="L1900">						}</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">						if (newEnsemble != null) { // unsetSuccess outside of lock</span>
<span class="nc" id="L1902">							unsetSuccessAndSendWriteRequest(newEnsemble, replaced);</span>
						}
					}
<span class="nc" id="L1905">				}, clientCtx.getMainWorkerPool().chooseThread(ledgerId));</span>
<span class="nc" id="L1906">	}</span>

	void unsetSuccessAndSendWriteRequest(List&lt;BookieSocketAddress&gt; ensemble, final Set&lt;Integer&gt; bookies) {
<span class="nc bnc" id="L1909" title="All 2 branches missed.">		for (PendingAddOp pendingAddOp : pendingAddOps) {</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">			for (Integer bookieIndex : bookies) {</span>
<span class="nc" id="L1911">				pendingAddOp.unsetSuccessAndSendWriteRequest(ensemble, bookieIndex);</span>
<span class="nc" id="L1912">			}</span>
<span class="nc" id="L1913">		}</span>
<span class="nc" id="L1914">	}</span>

	void registerOperationFailureOnBookie(BookieSocketAddress bookie, long entryId) {
<span class="nc bnc" id="L1917" title="All 2 branches missed.">		if (clientCtx.getConf().enableBookieFailureTracking) {</span>
<span class="nc" id="L1918">			bookieFailureHistory.put(bookie, entryId);</span>
		}
<span class="nc" id="L1920">	}</span>

<span class="nc" id="L1922">	static class NoopCloseCallback implements CloseCallback {</span>
<span class="nc" id="L1923">		static NoopCloseCallback instance = new NoopCloseCallback();</span>

		@Override
		public void closeComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="nc bnc" id="L1927" title="All 2 branches missed.">			if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1928">				LOG.warn(&quot;Close failed: {}&quot;, BKException.codeLogger(rc));</span>
			}
			// noop
<span class="nc" id="L1931">		}</span>
	}

	/**
	 * Get the current ensemble from the ensemble list. The current ensemble is the
	 * last ensemble in the list. The ledger handle uses this ensemble when
	 * triggering operations which work on the end of the ledger, such as adding new
	 * entries or reading the last add confirmed.
	 *
	 * &lt;p&gt;
	 * This method is also used by ReadOnlyLedgerHandle during recovery, and when
	 * tailing a ledger.
	 *
	 * &lt;p&gt;
	 * Generally, this method should only be called by LedgerHandle and not by the
	 * operations themselves, to avoid adding more dependencies between the classes.
	 * There are too many already.
	 */
	List&lt;BookieSocketAddress&gt; getCurrentEnsemble() {
		// Getting current ensemble from the metadata is only a temporary
		// thing until metadata is immutable. At that point, current ensemble
		// becomes a property of the LedgerHandle itself.
<span class="nc" id="L1953">		return LedgerMetadataUtils.getCurrentEnsemble(versionedMetadata.getValue());</span>
	}

	/**
	 * Return a {@link WriteSet} suitable for reading a particular entry. This will
	 * include all bookies that are cotna
	 */
	WriteSet getWriteSetForReadOperation(long entryId) {
<span class="nc bnc" id="L1961" title="All 2 branches missed.">		if (stickyBookieIndex != STICKY_READ_BOOKIE_INDEX_UNSET) {</span>
			// When sticky reads are enabled we want to make sure to take
			// advantage of read-ahead (or, anyway, from efficiencies in
			// reading sequential data from disk through the page cache).
			// For this, all the entries that a given bookie prefetches,
			// should read from that bookie.
			// For example, with e=2, w=2, a=2 we would have
			// B-1 B-2
			// e-0 X X
			// e-1 X X
			// e-2 X X
			//
			// In this case we want all the requests to be issued to B-1 (by
			// preference), so that cache hits will be maximized.
			//
			// We can only enable sticky reads if the ensemble==writeQuorum
			// otherwise the same bookie will not have all the entries
			// stored
<span class="nc" id="L1979">			return distributionSchedule.getWriteSet(stickyBookieIndex);</span>
		} else {
<span class="nc" id="L1981">			return distributionSchedule.getWriteSet(entryId);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>